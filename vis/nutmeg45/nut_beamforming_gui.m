function varargout = nut_beamforming_gui(varargin)
% NUT_BEAMFORMING_GUI M-file for nut_beamforming_gui.fig
%   A standard .fig-associated m-file. Launches the gui, returns handle,
%   performs casecallbacks.

% Last Modified by GUIDE v2.5 07-Jul-2004 16:40:47

% hObject    handle to figure
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% varargin   command line arguments to nut_beamforming_gui (see VARARGIN)

% Begin initialization code - DO NOT EDIT
gui_Singleton = 1;
gui_State = struct('gui_Name',       mfilename, ...
                   'gui_Singleton',  gui_Singleton, ...
                   'gui_OpeningFcn', @nut_beamforming_gui_OpeningFcn, ...
                   'gui_OutputFcn',  @nut_beamforming_gui_OutputFcn, ...
                   'gui_LayoutFcn',  @nut_beamforming_gui_LayoutFcn, ...
                   'gui_Callback',   []);
if nargin & ischar(varargin{1})
    gui_State.gui_Callback = str2func(varargin{1});
end
if nargout
   [varargout{1:nargout}] = gui_mainfcn(gui_State, varargin{:});
else
   gui_mainfcn(gui_State, varargin{:});
end
% End initialization code - DO NOT EDIT


%%-------------------------------------------
function nut_beamforming_gui_OpeningFcn(hObject, eventdata, handles, varargin)
% --- Executes just before nut_beamforming_gui is made visible.
handles.output = hObject;
guidata(hObject, handles);
set(hObject,'CloseRequestFcn','nut_beamforming_gui(''nut_beamforming_gui_CloseRequestFcn'',gcbf,[],guidata(gcbf))');

global nuts bolts;

set(hObject,'Color',[.93 .93 .92]);

% backwards compatibility and such
if (~isfield(nuts,'preprocessing') || ~isfield(nuts.preprocessing,'cs_timeinterval') || ~isfield(nuts.preprocessing,'stepsize') || ~isfield(nuts.preprocessing,'denoisertype') || ~isfield(nuts.preprocessing,'invtype') || ~isfield(nuts.preprocessing,'bf_timeinterval'))
   % default values
   nut_preprocessing_defaults
end
if (~isfield(nuts.preprocessing,'bf_ptimeinterval') || ~isfield(nuts.preprocessing,'avecov')) % backwards compatibility
    ptimeinterval = [nuts.meg.latency(1) -1];
    nuts.preprocessing.bf_ptimeinterval = ptimeinterval; % time interval for control period
    nuts.preprocessing.cs_ptimeinterval = ptimeinterval; % time interval for control period
    nuts.preprocessing.avecov = 1;
end 
if strcmp(nuts.preprocessing.beamformertype,'Default Beamformer')
    nuts.preprocessing.beamformertype='Eigenspace Vector Beamformer';
end
if strcmp(nuts.preprocessing.beamformertype,'LCMV Beamformer')
    nuts.preprocessing.beamformertype='LCMV Scalar Beamformer';
end
if strcmp(nuts.preprocessing.beamformertype,'LCMV Nonoptimized Beamformer')
    nuts.preprocessing.beamformertype='LCMV Vector Beamformer';
end

bf_flg = isfield(handles,'nut_eigen_axes');  % determines whether to display channel selections or beamformer tool

disp('Please do not click yet, GUI still make take awhile to load if large dataset');

% set up context menus for time series
bolts.sensoruicell = cell(size(nuts.meg.data,2),1);
for i=1:size(nuts.meg.data,2)
   sensorui = uicontextmenu;
   item1=uimenu(sensorui,'Label',nuts.meg.sensor_labels{i},'Enable','off');
   togglecmd = ['nut_beamforming_gui(''nut_toggle_channel'',gcbo,[],guidata(gcbf),' num2str(i) ')'];
   item2=uimenu(sensorui,'Label','Deselect','Callback',togglecmd);
   bolts.sensoruicell{i}=sensorui;
end

% normalize coil_coord using all channels
if isfield(nuts.meg,'chanmixMtx')
    [ind,jnd]=find(nuts.meg.chanmixMtx{1});jind=[ind jnd];
    [dummy,ujind]=unique(jind(:,1));
    if isfield(nuts.meg,'ft_gradlabels')
        coil_coord = nuts.meg.sensorCoord(jind(ujind(match_str(nuts.meg.ft_gradlabels,nuts.meg.sensor_labels)),2),:);
    else
        coil_coord = nuts.meg.sensorCoord(jind(ujind,2),:);
    end
else
    coil_coord = nuts.meg.sensorCoord(:,:,1);
end
bolts.plot_bfield.max_value1 = max(abs(coil_coord(:,1)));
bolts.plot_bfield.max_value2 = max(abs(coil_coord(:,2)));
coil_coord(:,2) = coil_coord(:,2)*bolts.plot_bfield.max_value1/bolts.plot_bfield.max_value2; % make extent of first and second columns equal
bolts.plot_bfield.max_value2 = max(abs(coil_coord(:,2)));
coil_coord(:,3) = coil_coord(:,3) - min(coil_coord(:,3)); % make min value 0 and max value 1
coil_coord(:,3) = coil_coord(:,3)/max(coil_coord(:,3));

% convert 3-d coil_coord into 2-d variable, out
out(:,1) = coil_coord(:,1).*exp(-coil_coord(:,3));
out(:,2) = coil_coord(:,2).*exp(-coil_coord(:,3));

% normalize to uniformly fill a circle
out(:,1) = out(:,1)*bolts.plot_bfield.max_value1/max(abs(out(:,1)));
out(:,2) = out(:,2)*bolts.plot_bfield.max_value2/max(abs(out(:,2)));

% adjust for size of border
bolts.plot_bfield.border = 4;
bolts.plot_bfield.resolution = 100;
bolts.plot_bfield.out = out*bolts.plot_bfield.resolution/(bolts.plot_bfield.resolution + bolts.plot_bfield.border);

% initial/previous values
if ~bf_flg
   set(handles.nut_time1_cs_text,'String',nuts.preprocessing.cs_timeinterval(1));
   set(handles.nut_time2_cs_text,'String',nuts.preprocessing.cs_timeinterval(2));
else
   set(handles.nut_time1_cs_text,'String',nuts.preprocessing.bf_timeinterval(1));
   set(handles.nut_time2_cs_text,'String',nuts.preprocessing.bf_timeinterval(2));
   set(handles.nut_ptime1_cs_text,'String',nuts.preprocessing.bf_ptimeinterval(1));
   set(handles.nut_ptime2_cs_text,'String',nuts.preprocessing.bf_ptimeinterval(2));
end
set(handles.nut_baseline,'Value',nuts.preprocessing.baseline);
set(handles.nut_notch,'Value',nuts.preprocessing.notch);
set(handles.nut_bpf,'Value',nuts.preprocessing.bpf);
set(handles.nut_bpf_low_cutoff,'String',num2str(nuts.preprocessing.bpf_low_cutoff));
set(handles.nut_bpf_high_cutoff,'String',num2str(nuts.preprocessing.bpf_high_cutoff));
set(handles.nut_shift_stepsize,'String',num2str(nuts.preprocessing.stepsize));

bolts.ts_plot = handles.nut_ts_axes;
if bf_flg
   bolts.eigen_plot = handles.nut_eigen_axes;
   bolts.inset_axes = handles.nut_inset_axes;
   denoiservalue = find(strcmp(get(handles.nut_whichdenoiser,'String'),nuts.preprocessing.denoisertype));
   beamformervalue = find(strcmp(get(handles.nut_whichbeamformer,'String'),nuts.preprocessing.beamformertype));
   invtypevalue = find(strcmp(get(handles.nut_which_invtype,'String'),nuts.preprocessing.invtype));
   set(handles.nut_whichdenoiser,'Value',denoiservalue);
   set(handles.nut_whichbeamformer,'Value',beamformervalue);
   set(handles.nut_which_invtype,'Value',invtypevalue);
   set(handles.nut_signalspace_text,'String',int2str(nuts.preprocessing.signalspace));
   set(handles.nut_avecov_box,'Value',nuts.preprocessing.avecov);
   nut_toggle_eigenplot(nuts.preprocessing.beamformertype,handles);
   nut_baseline_Callback(hObject,eventdata,handles);
%     eval([strrep(['nut_' nuts.preprocessing.beamformertype],' ','_') '(handles);']);
else
   bolts.select_plot = handles.nut_select_axes;
   nut_amplitude_Callback(hObject,eventdata,handles);
end

bolts.latency=nuts.meg.latency;

if isfield(nuts.meg,'eegflag') && nuts.meg.eegflag
    bolts.flags.cn=0;
    bolts.flags.wn=1;
    bolts.flags.do_avref_leadpotential=1; % average reference leadfield for average referenced data
else
    bolts.flags.cn=1; % flag for column normalization ( aka lead field normalization )
    bolts.flags.wn=0; % flag for weight normalization
    warning('NOTE! default is now lead field normalization for all methods, not weight normalization');
end

%matters only for champagne
bolts.flags.champ.nem_ch=100;
bolts.flags.champ.ax=0;
bolts.flags.champ.multf=1;

%matters only for saketini
bolts.flags.sake.nem=20;
bolts.flags.sake.plot=0;
bolts.flags.sake.sbar_init='algo1';%'bf_ES'
bolts.flags.sake.xubar='reg';
bolts.flags.sake.updatelam=0;
bolts.flags.sake.a_init='magic_y1';
bolts.flags.sake.infer_nu=0;
bolts.flags.sake.iryy_init='vbfa';
bolts.flags.sake.phi_init='magic_y';

%matter only for NSEFALoc algos
bolts.flags.tb.plot=0;
bolts.flags.tb.nem=10;
bolts.flags.tb.applytoalldata=1;
bolts.flags.tb.usephiall=0;
bolts.flags.tb.nm_x=ceil(.1*length(nuts.meg.goodchannels));

%matter only for LFerror BF
bolts.flags.LFerror.nem=3;
bolts.flags.LFerror.plot=0;
bolts.flags.LFerror.sbar_init='bf_ES';%'algo1'
bolts.flags.LFerror.updatelam=0;
bolts.flags.LFerror.phi_init='ssT';%'magic_y';
bolts.flags.LFerror.sbar_up='reg';

%matter only for BFprior
bolts.flags.bfprior.nem=10;
bolts.flags.bfprior.plot=1;
% bolts.flags.bfprior=params.sakeflags;
% bolts.flags.bfprior.Rprior=params.sb;
% bolts.flags.bfprior.nm_pre=floor(length(nuts.meg.goodchannels)/6);
% bolts.flags.bfprior.nl=max(nuts.preprocessing.signalspace);
% bolts.flags.bfprior.niter=10;
% bolts.flags.bfprior.plot=0;
% bolts.flags.bfprior.timept(1)=timept1;
% bolts.flags.bfprior.timept(2)=timept2;
% bolts.flags.bfprior.alpha=1;

disp('GUI finished loading');

return


%%-------------------------------------------
function varargout = nut_beamforming_gui_OutputFcn(hObject, eventdata, handles)
% --- Outputs from this function are returned to the command line.
varargout{1} = handles.output;
return;


% --- Executes when user attempts to close nut_beamforming_gui.
function nut_beamforming_gui_CloseRequestFcn(hObject, eventdata, handles)
% hObject    handle to Channel Select Tool (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

clear global bolts
delete(handles.nut_beamforming_fig);


%%-------------------------------------------
function nut_time1_cs_text_CreateFcn(hObject, eventdata, handles)
% --- Executes during object creation, after setting all properties.
% Time interval left edge.
if ispc
    set(hObject,'BackgroundColor','white');
else
    set(hObject,'BackgroundColor',get(0,'defaultUicontrolBackgroundColor'));
end


%%-------------------------------------------
function nut_time2_cs_text_CreateFcn(hObject, eventdata, handles)
% --- Executes during object creation, after setting all properties.
% Time interval right edge.
if ispc
    set(hObject,'BackgroundColor','white');
else
    set(hObject,'BackgroundColor',get(0,'defaultUicontrolBackgroundColor'));
end


%%-------------------------------------------
function threshold_text_CreateFcn(hObject, eventdata, handles)
% --- Executes during object creation, after setting all properties.
if ispc
    set(hObject,'BackgroundColor','white');
else
    set(hObject,'BackgroundColor',get(0,'defaultUicontrolBackgroundColor'));
end

return;

%%-------------------------------------------
function nut_interval_button_Callback(hObject, eventdata, handles)
% --- Executes on button press in nut_interval_button.
% "Select Interval" button
global nuts bolts;

% remove vertical interval lines
%lh = get(handles.nut_ts_axes,'Children');
%set(lh(1:2),'Visible','off'); % assumes first 2 children are the red vertical lines
set(handles.nut_vert_lines,'Visible','off'); % makes red vertical lines disappear

% get first mouse click
[time1,jnk,button] = ginput(1);

time1 = round(time1*10)/10;
if time1 < nuts.meg.latency(1), time1 = nuts.meg.latency(1); end
if time1 > nuts.meg.latency(end), time1 = nuts.meg.latency(end); end

% show first vertical line
%set(lh(2),'XData',time1*ones(1,2),'Visible','on');
set(handles.nut_vert_lines(1),'XData',time1*ones(1,2),'Visible','on');

if button == 3 % first click is right mouse button (sets both vertical lines to have the same x-axis value)
   %set(lh(1),'XData',time1*ones(1,2),'Visible','on');
   set(handles.nut_vert_lines(2),'XData',time1*ones(1,2),'Visible','on');
   time2 = time1;
else % first click is left or middle button
   % get second mouse click
   [time2,jnk,button] = ginput(1);
   
   if button % any button
      time2 = round(time2*10)/10;
      if time2 < nuts.meg.latency(1), time2 = nuts.meg.latency(1); end
      if time2 > nuts.meg.latency(end), time2 = nuts.meg.latency(end); end
      
      % make sure left vertical line is associated with nut_time1_cs_text
      if time2 < time1
         tmp = time1; time1 = time2; time2 = tmp;
         %set(lh(2),'XData',time1*ones(1,2));
         set(handles.nut_vert_lines(1),'XData',time1*ones(1,2));
      end

      % show second vertical line
      %set(lh(1),'XData',time2*ones(1,2),'Visible','on'); % assumes the first child is the rightmost red vertical line
      set(handles.nut_vert_lines(2),'XData',time2*ones(1,2),'Visible','on');
   end
end

% update text boxes
set(handles.nut_time1_cs_text,'String',num2str(time1));
set(handles.nut_time2_cs_text,'String',num2str(time2));
bf_flg = isfield(handles,'nut_eigen_axes');  % determines whether to display channel selections or beamformer tool
if bf_flg
   nuts.preprocessing.bf_timeinterval = [time1 time2];
else
   nuts.preprocessing.cs_timeinterval = [time1 time2];
end

% update right axes
nut_baseline_Callback(hObject, eventdata, handles);

return;


%%-------------------------------------------
function nut_signalspace_text_CreateFcn(hObject, eventdata, handles)
% --- Executes during object creation, after setting all properties.
if ispc
    set(hObject,'BackgroundColor','white');
else
    set(hObject,'BackgroundColor',get(0,'defaultUicontrolBackgroundColor'));
end

%%-------------------------------------------
function nut_select_beamformer(hObject,eventdata,handles)
% opens and closes eigenplot as needed by the currently selected beamformer
% calls beamforming algorithm using a single input argument

ndx = get(handles.nut_whichbeamformer,'Value');
beam_cell = get(handles.nut_whichbeamformer,'String');
% beam_str = [strrep(['nut_' beam_cell{ndx}],' ','_') '(handles);'];
nut_toggle_eigenplot(beam_cell{ndx},handles);
% eval(beam_str);

return;

%%---------------------------------------------------------------
function nut_toggle_eigenplot(beam_str,handles)

switch beam_str
    case {'Default Beamformer','Beamspace','Default Beamformer thph','Original Beamformer','Point Suppression','Region Suppression','Thresholded Lead Field','Yu Yeh GEIB','Saketini'}
        lh = [handles.nut_eigen_axes; get(handles.nut_eigen_axes,'Children')];
        viewsingle_num = str2num(get(handles.nut_viewsingle_edit,'String'));
        if length(viewsingle_num) ~= 1 || viewsingle_num ~= 0 % don't make it visible unless it should be visible
            lh = [lh; handles.nut_inset_axes; get(handles.nut_inset_axes,'Children')];
        end
        lh = [lh; handles.nut_signalspace_edit; handles.nut_viewsingle_edit; handles.nut_signalspace_text'; handles.nut_single_eigenproj_text];
        lh = [lh; handles.nut_logplot_box; handles.nut_cumulative_box];
        lh = [lh; handles.nut_viewsefa_text; handles.nut_sefa_nl_nm_text];
        lh = [lh; handles.nut_nm_edit; handles.nut_nm_text];
        set(lh,'Visible','on')
        
        offhandles = [handles.nem_label, handles.nem_ch, handles.champ_which_ax, handles.ax_label, handles.multf_label, handles.multf, handles.champ_help];
        set(offhandles, 'Visible', 'off')
    case {'Beamspace noES','LCMV Nonoptimized Beamformer','sLORETA','dSPM','LCMV Beamformer','LCMV Scalar Beamformer','LCMV Vector Beamformer','TRACS Beamformer'}
        lh = [handles.nut_eigen_axes; get(handles.nut_eigen_axes,'Children')];
        lh = [lh; handles.nut_inset_axes; get(handles.nut_inset_axes,'Children')];
        lh = [lh; handles.nut_signalspace_edit; handles.nut_viewsingle_edit; handles.nut_signalspace_text'; handles.nut_single_eigenproj_text];
        lh = [lh; handles.nut_logplot_box; handles.nut_cumulative_box];        
        lh = [lh; handles.nem_label; handles.nem_ch; handles.champ_which_ax;  handles.ax_label; handles.multf_label; handles.multf; handles.champ_help];
        set(lh,'Visible','off')
        
        lh = [handles.nut_viewsefa_text; handles.nut_sefa_nl_nm_text];
        lh = [lh; handles.nut_nm_edit; handles.nut_nm_text];
        set(lh,'Visible','on')
        
    case {'Eigenspace Scalar Beamformer','Eigenspace Vector Beamformer'}
        lh = [handles.nem_label; handles.nem_ch; handles.champ_which_ax;  handles.ax_label; handles.multf_label; handles.multf; handles.champ_help];
        set(lh,'Visible','off')

    case {'Champagne'}
        lh = [handles.nut_eigen_axes; get(handles.nut_eigen_axes,'Children')];
        lh = [lh; handles.nut_inset_axes; get(handles.nut_inset_axes,'Children')];
        lh = [lh; handles.nut_signalspace_edit; handles.nut_viewsingle_edit; handles.nut_signalspace_text'; handles.nut_single_eigenproj_text];
        lh = [lh; handles.nut_logplot_box; handles.nut_cumulative_box];
        lh = [lh; handles.nut_viewsefa_text; handles.nut_sefa_nl_nm_text];
        lh = [lh; handles.nut_nm_edit; handles.nut_nm_text];
        set(lh,'Visible','off')
        
        onhandles = [handles.nem_label, handles.nem_ch, handles.champ_which_ax,  handles.ax_label, handles.multf_label, handles.multf, handles.champ_help];
        set(onhandles, 'Visible', 'on')
end
return


%%-------------------------------------------
function nut_proceed_button_Callback(hObject, eventdata, handles,varargin)
% --- Executes on button press in nut_proceed_button.
global nuts bolts

set(handles.nut_proceed_button,'Enable','off');

bolts.flags.champ.ax = bolts.flags.champ.axtype{get(handles.champ_which_ax,'Value')};

outname = get(handles.nut_outname_box,'String');
nuts.preprocessing.signalspace = str2num(get(handles.nut_signalspace_text,'String'));
bolts.flags.sake.nm = str2num(get(handles.nut_nm_edit,'String'));
bolts.flags.tb.nm_x = str2num(get(handles.nut_nm_edit,'String'));
bolts.flags.tb.nl=max(nuts.preprocessing.signalspace);
bolts.flags.sake.nl=max(nuts.preprocessing.signalspace);
bolts.flags.qsub = get(handles.nut_qsub_box,'Value');
bolts.flags.LFerror.nm_pre=floor(length(nuts.meg.goodchannels)/6);
bolts.flags.LFerror.nl=max(nuts.preprocessing.signalspace);

time1 = str2double(get(handles.nut_time1_cs_text,'String'));
time2 = str2double(get(handles.nut_time2_cs_text,'String'));
ptime1 = str2double(get(handles.nut_ptime1_cs_text,'String')); % baseline/control/passive time start
ptime2 = str2double(get(handles.nut_ptime2_cs_text,'String')); % baseline/control/passive time end
bf_flg = isfield(handles,'nut_eigen_axes');  % determines whether to display channel selections or beamformer tool
if bf_flg
   nuts.preprocessing.bf_timeinterval = [time1 time2];
   nuts.preprocessing.bf_ptimeinterval = [ptime1 ptime2];
else
   nuts.preprocessing.cs_timeinterval = [time1 time2];
   nuts.preprocessing.cs_ptimeinterval = [ptime1 ptime2];
end

timept1 = dsearchn(nuts.meg.latency,time1);
timept2 = dsearchn(nuts.meg.latency,time2);
ptimept1 = dsearchn(nuts.meg.latency,ptime1);
ptimept2 = dsearchn(nuts.meg.latency,ptime2);
bolts.flags.doW2 = get(handles.nut_W2_box,'Value'); % the flag that says that you actually care about the control time window :)
bolts.flags.ptime=[ptimept1 ptimept2];
bolts.flags.time=[timept1 timept2];
bolts.flags.avecov=get(handles.nut_avecov_box,'Value');

bolts.flags.tb.timepta=[timept1 timept2];
bolts.flags.tb.timeptc=[ptimept1 ptimept2];
bolts.flags.sake.timepta=[timept1 timept2];
bolts.flags.sake.timeptc=[ptimept1 ptimept2];
bolts.flags.LFerror.timept=[timept1 timept2];


% call denoising algorithm
nuts.preprocessing.denoisertype = bolts.denoise{get(handles.nut_whichdenoiser,'Value')};
denoise_str = strrep(['nut_' nuts.preprocessing.denoisertype],' ','_');
feval(denoise_str,handles,nuts.preprocessing.signalspace,timept1,timept2,ptimept1,ptimept2); % update bolts.meg, bolts.params.Rzz1 (bolts.meg should be updated from nuts.meg.data every time Beamformer Tool is opened otherwise the denoising will be applied multiple times)

% call code that computes inverse of autocorrelation/covariance matrix
nuts.preprocessing.invtype = bolts.invtype{get(handles.nut_which_invtype,'Value')};
% nut_cov_eigen(nuts.preprocessing.invtype); % invert Rzz1 matrix and store in bolts

regtest = 0;
if(regtest)
    warning('SARANG has forced regularization here for research purposes. NORMALLY SHOULD BE OFF!!!!')
    bolts.params.InvRzz1=nut_inv(double(bolts.params.Rzz1),nuts.preprocessing.invtype,'always',1e-2,bolts.params.Rzz1_mineigUnave);
%     bolts.params.InvRzz1=nut_inv(double(bolts.params.Rzz1),'pinv','always',1e-2,bolts.params.Rzz1_mineigUnave);
else
    bolts.params.InvRzz1=nut_inv(double(bolts.params.Rzz1),nuts.preprocessing.invtype,[],[],bolts.params.Rzz1_mineigUnave);
end

% call beamformer/localization code
nuts.preprocessing.beamformertype = bolts.algorithms{get(handles.nut_whichbeamformer,'Value')};
[beam,outname]=nut_generate_beamforming_activations(outname,timept1,timept2,nuts.preprocessing.beamformertype);
clear beam

% if(bolts.stop)  % user hit cancel, stop operation
%     return
% end

%clear global bolts; pack; % jettison bolts (no longer needed) and pack down the remainder...

close(gcbf);
if(strcmp(version('-release'),'14') || strcmp(version('-release'),'2006a'))
    clear global bolts; % jettison bolts (no longer needed)...
    nut_results_viewer(outname);
else
    bolts.outname=outname;
    nut_results_viewer;
    clear global bolts; % jettison bolts (no longer needed)...
end


%%-------------------------------------------
function nut_whichbeamformer_CreateFcn(hObject, eventdata, handles)
% --- Executes during object creation, after setting all properties.
if ispc
    set(hObject,'BackgroundColor','white');
else
    set(hObject,'BackgroundColor',get(0,'defaultUicontrolBackgroundColor'));
end

%%-------------------------------------------
function nut_which_invtype_CreateFcn(hObject, eventdata, handles)
% --- Executes during object creation, after setting all properties.
if ispc
    set(hObject,'BackgroundColor','white');
else
    set(hObject,'BackgroundColor',get(0,'defaultUicontrolBackgroundColor'));
end

%%-------------------------------------------
function nut_baseline_CreateFcn(hObject, eventdata, handles)
% --- Executes during object creation, after setting all properties.
if ispc
    set(hObject,'BackgroundColor','white');
else
    set(hObject,'BackgroundColor',get(0,'defaultUicontrolBackgroundColor'));
end


%%-------------------------------------------
function nut_baseline_Callback(hObject, eventdata, handles)
% --- Executes on selection change in baseline.
global nuts bolts

calling_tag = get(hObject,'Tag');
fs = nuts.meg.srate;
bf_flg = isfield(handles,'nut_eigen_axes');  % determines whether to display channel selections or beamformer tool

% verify/update parameters
switch(calling_tag)
   case 'nut_beamforming_fig'
      interval_flg = 0;
      replot_flg = 1;
   case 'nut_interval_button'
      interval_flg = 1;
      replot_flg = 0;
   case 'nut_redeem'
      interval_flg = 0;
      replot_flg = 1;
   case 'nut_select_button'
      interval_flg = 0;
      replot_flg = 1;
   case 'nut_shift_left'
      interval_flg = 1;
      replot_flg = 0;
      time1 = str2double(get(handles.nut_time1_cs_text,'String'));
      time2 = str2double(get(handles.nut_time2_cs_text,'String'));
      stp = str2double(get(handles.nut_shift_stepsize,'String'));
      if time1-stp >= nuts.meg.latency(1)
         delta = stp;
      else
         delta = time1 - nuts.meg.latency(1);
      end
      time1 = time1 - delta;
      time2 = time2 - delta;
      set(handles.nut_time1_cs_text,'String',num2str(time1));
      set(handles.nut_time2_cs_text,'String',num2str(time2));
      if bf_flg
         nuts.preprocessing.bf_timeinterval = [time1 time2];
      else
         nuts.preprocessing.cs_timeinterval = [time1 time2];
      end
      %lh = get(handles.nut_ts_axes,'Children');
      %set(lh(2),'XData',time1*ones(1,2));
      %set(lh(1),'XData',time2*ones(1,2));
      set(handles.nut_vert_lines(1),'XData',time1*ones(1,2));
      set(handles.nut_vert_lines(2),'XData',time2*ones(1,2));
   case 'nut_shift_right'
      interval_flg = 1;
      replot_flg = 0;
      time1 = str2double(get(handles.nut_time1_cs_text,'String'));
      time2 = str2double(get(handles.nut_time2_cs_text,'String'));
      stp = str2double(get(handles.nut_shift_stepsize,'String'));
      if time2+stp <= nuts.meg.latency(end)
         delta = stp;
      else
         delta = nuts.meg.latency(end) - time2;
      end
      time1 = time1 + delta;
      time2 = time2 + delta;
      set(handles.nut_time1_cs_text,'String',num2str(time1));
      set(handles.nut_time2_cs_text,'String',num2str(time2));
      if bf_flg
         nuts.preprocessing.bf_timeinterval = [time1 time2];
      else
         nuts.preprocessing.cs_timeinterval = [time1 time2];
      end
      %lh = get(handles.nut_ts_axes,'Children');
      %set(lh(2),'XData',time1*ones(1,2));
      %set(lh(1),'XData',time2*ones(1,2));
      set(handles.nut_vert_lines(1),'XData',time1*ones(1,2));
      set(handles.nut_vert_lines(2),'XData',time2*ones(1,2));
   case 'nut_shift_stepsize'
      interval_flg = 1;
      replot_flg = 0;
      stp = round(str2double(get(hObject,'String'))*10)/10;
      if stp < 0, stp = 0; end
      set(hObject,'String',num2str(stp));
      nuts.preprocessing.stepsize = stp;
   case 'nut_time1_cs_text'
      interval_flg = 1;
      replot_flg = 0;
      time1 = round(str2double(get(handles.nut_time1_cs_text,'String'))*10)/10;
      if time1 < nuts.meg.latency(1), time1 = nuts.meg.latency(1); end
      if time1 > nuts.meg.latency(end), time1 = nuts.meg.latency(end); end
      time2 = str2double(get(handles.nut_time2_cs_text,'String'));
      if time1 > time2, time2 = time1; set(handles.nut_time2_cs_text,'String',num2str(time2)); end
      set(handles.nut_time1_cs_text,'String',num2str(time1));
      if bf_flg
         nuts.preprocessing.bf_timeinterval = [time1 time2];
      else
         nuts.preprocessing.cs_timeinterval = [time1 time2];
      end
      %lh = get(handles.nut_ts_axes,'Children');
      %set(lh(2),'XData',time1*ones(1,2));
      %set(lh(1),'XData',time2*ones(1,2));
      set(handles.nut_vert_lines(1),'XData',time1*ones(1,2));
      set(handles.nut_vert_lines(2),'XData',time2*ones(1,2));
   case 'nut_time2_cs_text'
      interval_flg = 1;
      replot_flg = 0;
      time2 = round(str2double(get(handles.nut_time2_cs_text,'String'))*10)/10;
      if time2 < nuts.meg.latency(1), time2 = nuts.meg.latency(1); end
      if time2 > nuts.meg.latency(end), time2 = nuts.meg.latency(end); end
      time1 = str2double(get(handles.nut_time1_cs_text,'String'));
      if time2 < time1, time1 = time2; set(handles.nut_time1_cs_text,'String',num2str(time1)); end
      set(handles.nut_time2_cs_text,'String',num2str(time2));
      if bf_flg
         nuts.preprocessing.bf_timeinterval = [time1 time2];
      else
         nuts.preprocessing.cs_timeinterval = [time1 time2];
      end
      %lh = get(handles.nut_ts_axes,'Children');
      %set(lh(2),'XData',time1*ones(1,2));
      %set(lh(1),'XData',time2*ones(1,2));
      set(handles.nut_vert_lines(1),'XData',time1*ones(1,2));
      set(handles.nut_vert_lines(2),'XData',time2*ones(1,2));
   case 'nut_ptime1_cs_text'
      interval_flg = 1;
      replot_flg = 0;
      ptime1 = round(str2double(get(handles.nut_ptime1_cs_text,'String'))*10)/10;
      if ptime1 < nuts.meg.latency(1), ptime1 = nuts.meg.latency(1); end
      if ptime1 > nuts.meg.latency(end), ptime1 = nuts.meg.latency(end); end
      ptime2 = str2double(get(handles.nut_ptime2_cs_text,'String'));
      if ptime1 > ptime2, ptime2 = ptime1; set(handles.nut_ptime2_cs_text,'String',num2str(ptime2)); end
      set(handles.nut_ptime1_cs_text,'String',num2str(ptime1));
      if bf_flg
         nuts.preprocessing.bf_ptimeinterval = [ptime1 ptime2];
      else
         nuts.preprocessing.cs_ptimeinterval = [ptime1 ptime2];
      end
   case 'nut_ptime2_cs_text'
      interval_flg = 1;
      replot_flg = 0;
      ptime2 = round(str2double(get(handles.nut_ptime2_cs_text,'String'))*10)/10;
      if ptime2 < nuts.meg.latency(1), ptime2 = nuts.meg.latency(1); end
      if ptime2 > nuts.meg.latency(end), ptime2 = nuts.meg.latency(end); end
      ptime1 = str2double(get(handles.nut_ptime1_cs_text,'String'));
      if ptime2 < ptime1, ptime1 = ptime2; set(handles.nut_ptime1_cs_text,'String',num2str(ptime1)); end
      set(handles.nut_ptime2_cs_text,'String',num2str(ptime2));
      if bf_flg
         nuts.preprocessing.bf_ptimeinterval = [ptime1 ptime2];
      else
         nuts.preprocessing.cs_ptimeinterval = [ptime1 ptime2];
      end
   case 'nut_baseline'
      interval_flg = 0;
      replot_flg = 1;
      nuts.preprocessing.baseline = get(hObject,'Value');
   case 'nut_notch'
      interval_flg = 0;
      replot_flg = 1;
      nuts.preprocessing.notch = get(hObject,'Value');
   case 'nut_bpf'
      interval_flg = 0;
      replot_flg = 1;
      nuts.preprocessing.bpf = get(hObject,'Value');
   case 'nut_avecov_box'
      interval_flg = 0;
      replot_flg = 1;
      nuts.preprocessing.avecov = get(hObject,'Value');
   case 'nut_bpf_low_cutoff'
      interval_flg = 0;
      replot_flg = 1;
      tmp = round(str2double(get(hObject,'String'))*10)/10;
      if tmp < 0, tmp = 0; end
      if tmp >= fs/2, tmp = fix(fs/2)-0.1; end
      nuts.preprocessing.bpf_low_cutoff = tmp;
      set(handles.nut_bpf_low_cutoff,'String',num2str(tmp))
   case 'nut_bpf_high_cutoff'
      interval_flg = 0;
      replot_flg = 1;
      tmp = round(str2double(get(hObject,'String'))*10)/10;
      if tmp < 0, tmp = 0; end
      if tmp >= fs/2, tmp = fix(fs/2)-0.1; end
      nuts.preprocessing.bpf_high_cutoff = tmp;
      set(handles.nut_bpf_high_cutoff,'String',num2str(tmp))
   case 'nut_save_channels_button'
      interval_flg = 1;
      replot_flg = 0;
   case 'nut_load_channels_button'
      interval_flg = 0;
      replot_flg = 1;
otherwise
   error('Invalid line handle in nut_baseline_Callback')
end

if interval_flg == 1 % grab old data
    data = bolts.evoked;
else % determine data by applying pre-processing to original data
    warning('SSD changed filter settings: filters work only on ERP/ERF now, notch parameters also changed')
    if size(nuts.meg.data,2)>length(nuts.meg.goodchannels)
        bolts.meg = nuts.meg.data(:,nuts.meg.goodchannels,:); % start with unmodified good channels
    else
        bolts.meg = nuts.meg.data;
    end
    bolts.evoked = mean(bolts.meg,3); % work with average for purposes of plotting, etc...data

    ptimepts(1)=dsearchn(nuts.meg.latency,nuts.preprocessing.bf_ptimeinterval(1));
    ptimepts(2)=dsearchn(nuts.meg.latency,nuts.preprocessing.bf_ptimeinterval(2));
    %   data =
    %   nut_filter(data,nuts.meg.latency,fs,nuts.preprocessing.baseline,nuts.preprocessing.notch,nuts.preprocessing.bpf,nuts.preprocessing.bpf_low_cutoff,nuts.preprocessing.bpf_high_cutoff);
    if nuts.preprocessing.notch==2
               bolts.meg=nut_filter2(bolts.meg,'firls','notch',floor(size(nuts.meg.data,1)/3),47,53,nuts.meg.srate,nuts.preprocessing.baseline);
        bolts.evoked=nut_filter2(bolts.evoked,'firls','notch',20,47,53,nuts.meg.srate,nuts.preprocessing.baseline);
    elseif nuts.preprocessing.notch==3
         bolts.meg=nut_filter2(bolts.meg,'firls','notch',floor(size(nuts.meg.data,1)/3),57,63,nuts.meg.srate,nuts.preprocessing.baseline);
        bolts.evoked=nut_filter2(bolts.evoked,'firls','notch',30,57,63,nuts.meg.srate,nuts.preprocessing.baseline);
    end
    if nuts.preprocessing.bpf
        if nuts.preprocessing.baseline > 1
             bolts.meg = nut_filter2(bolts.meg,'butter','bp',4,nuts.preprocessing.bpf_low_cutoff,nuts.preprocessing.bpf_high_cutoff,nuts.meg.srate,ptimepts);
            bolts.evoked = nut_filter2(bolts.evoked,'firls','bp',45,nuts.preprocessing.bpf_low_cutoff,nuts.preprocessing.bpf_high_cutoff,nuts.meg.srate,ptimepts);

        else
             bolts.meg = nut_filter2(bolts.meg,'butter','bp',4,nuts.preprocessing.bpf_low_cutoff,nuts.preprocessing.bpf_high_cutoff,nuts.meg.srate,nuts.preprocessing.baseline);
            bolts.evoked = nut_filter2(bolts.evoked,'firls','bp',45,nuts.preprocessing.bpf_low_cutoff,nuts.preprocessing.bpf_high_cutoff,nuts.meg.srate,nuts.preprocessing.baseline);
        end
    end
    if(nuts.preprocessing.baseline>1 & ~nuts.preprocessing.bpf)
         bolts.meg = nut_filter2(bolts.meg,'butter','baseline_only',4,nuts.preprocessing.bpf_low_cutoff,nuts.preprocessing.bpf_high_cutoff,nuts.meg.srate,ptimepts);
        bolts.evoked = nut_filter2(bolts.evoked,'butter','baseline_only',4,nuts.preprocessing.bpf_low_cutoff,nuts.preprocessing.bpf_high_cutoff,nuts.meg.srate,ptimepts);
    end

    data = bolts.evoked;
end

% plot data
bolts.ts_plot = handles.nut_ts_axes;
axes(bolts.ts_plot); % this prevents plot from going into SPM image

% used to draw red interval lines
x1 = str2double(get(handles.nut_time1_cs_text,'String'));
x2 = str2double(get(handles.nut_time2_cs_text,'String'));
%lh = get(handles.nut_ts_axes,'Children');

if replot_flg
   if size(data,2) > 0
      ploth = plot(nuts.meg.latency,bolts.evoked); axis tight; xlabel('Time (ms)');ylabel(' Magnetic Field (T)');
      if isfield(nuts.meg,'eegflag') & nuts.meg.eegflag; ylabel(' Electric Potential (V)'); else; ylabel(' Magnetic Field (T)'); end;  % NUTEEG mod
   else
      cla, axis([nuts.meg.latency(1) nuts.meg.latency(end)  0 1])
   end
   % plot red vertical interval lines
   hold on, a = axis;
   handles.nut_vert_lines = plot([x1 x1],a(3:4),'r',[x2 x2],a(3:4),'r'); % plot intervals
   guidata(hObject,handles);

   hold off
   
   % add context menus for sensor id/deselection for view/select window
   if ~bf_flg & size(data,2)>0 % is this the view/select window (or the activation window)?
      set(ploth,{'UiContextMenu'},bolts.sensoruicell(nuts.meg.goodchannels));
   end
end

% add RMS to title of time series plot
axes(bolts.ts_plot); % this prevents plot from going into SPM image
time1 = dsearchn(nuts.meg.latency,x1);
time2 = dsearchn(nuts.meg.latency,x2);
rms_val = round(sqrt(mean(mean(data(time1:time2,:).^2)))*1e15*10)/10;
rms_str = num2str(rms_val);
if length(findstr(rms_str,'.')) == 0, rms_str = [rms_str '.0']; end % next line expects a decimal point and one digit to the right of the decimal point
if rms_val >= 1000, rms_str = [rms_str(1:end-5) ',' rms_str(end-4:end)]; end
if ~isfield(nuts.meg,'eegflag') | ~nuts.meg.eegflag; title(['RMS = ' rms_str ' fT']); else; title(['RMS = ' rms_str ' uV']); end;	% NUTEEG mod

% plot data for second axes
if ~strcmp(calling_tag,'nut_shift_stepsize')
   if bf_flg
      nut_plot_eigen(hObject,eventdata,handles);
   else
      plot_bfield(hObject,eventdata,handles);
   end
end

return

%%-------------------------------------------
function nut_judge_Callback(hObject,eventdata,handles)
% move channels between list boxes
global nuts bolts

badchannels = good2bad(size(nuts.meg.data,2),nuts.meg.goodchannels);

if strcmp(get(hObject,'Tag'),'nut_renounce')
   ndx = get(handles.goodchannel_list,'Value');
   if min(ndx) >= 1 & max(ndx) <= length(nuts.meg.goodchannels)
      good_length = length(nuts.meg.goodchannels) - length(ndx);
      if good_length ~= 0
         set(handles.goodchannel_list,'Value',min([min(ndx) good_length]));
      end
      badchannels = sort([badchannels nuts.meg.goodchannels(ndx)]);
      nuts.meg.goodchannels(ndx) = [];
   end
else % nut_redeem
   ndx = get(handles.badchannel_list,'Value');
   if min(ndx) >= 1 & max(ndx) <= length(badchannels)
      bad_length = length(badchannels) - length(ndx);
      if bad_length ~= 0
         set(handles.badchannel_list,'Value',min([min(ndx) bad_length]));
      end
      nuts.meg.goodchannels = sort([nuts.meg.goodchannels badchannels(ndx)]);
      badchannels(ndx) = [];
   end
end

set(handles.goodchannel_list,'String',nuts.meg.sensor_labels(nuts.meg.goodchannels));
set(handles.badchannel_list,'String',nuts.meg.sensor_labels(badchannels));

nut_baseline_Callback(handles.nut_redeem, eventdata, handles)

return

%%-------------------------------------------
function nut_select_Callback(hObject,eventdata,handles)
% add the group of sensors designated by the drop back
global nuts bolts

badchannels = good2bad(size(nuts.meg.data,2),nuts.meg.goodchannels);
select = strcmp(get(hObject,'Tag'),'nut_select_button');
ndx = get(handles.nut_select_group,'Value');

if ndx == 1 % select/deselect all
   if select
      nuts.meg.goodchannels = sort([nuts.meg.goodchannels badchannels]);
      badchannels = [];
   else % deselect
      badchannels = sort([badchannels nuts.meg.goodchannels]);
      nuts.meg.goodchannels = [];
   end
else
   if strcmp(nuts.meg.sensor_labels{1}(1),'M')  %if naming like CTF?
      search_char = ' LRZFPOTC';
      search_ndx = [0 2 2 2 3 3 3 3 3];
   else  % if naming like BTi?
      search_char = ' LR';  
      search_ndx = [0 1 1];
   end

   if select
      lh = handles.badchannel_list;
   else
      lh = handles.goodchannel_list;
   end

   schar = search_char(ndx);
   sndx = search_ndx(ndx);
   label_data = get(lh,'String');

   % find the indices of the items to be moved
   ndx2 = [];
   for i = 1:length(label_data)
      if upper(label_data{i}(sndx)) == schar
         ndx2 = [ndx2 i];
      end
   end

   if select
      nuts.meg.goodchannels = sort([nuts.meg.goodchannels badchannels(ndx2)]);
      badchannels(ndx2) = [];
   else % deselect
      badchannels = sort([badchannels nuts.meg.goodchannels(ndx2)]);
      nuts.meg.goodchannels(ndx2) = [];
   end
end

ndx = get(handles.badchannel_list,'Value');
if length(badchannels) > 0
   set(handles.badchannel_list,'Value',min([min(ndx) length(badchannels)]));
else
   set(handles.badchannel_list,'Value',1);
end

ndx = get(handles.goodchannel_list,'Value');
if length(nuts.meg.goodchannels) > 0
   set(handles.goodchannel_list,'Value',min([min(ndx) length(nuts.meg.goodchannels)]));
else
   set(handles.goodchannel_list,'Value',1);
end

set(handles.goodchannel_list,'String',nuts.meg.sensor_labels(nuts.meg.goodchannels));
set(handles.badchannel_list,'String',nuts.meg.sensor_labels(badchannels));

nut_baseline_Callback(handles.nut_select_button, eventdata, handles);

return

%%-------------------------------------------
function nut_loadchannels_CreateFcn(hObject,eventdata,handles)
% load channels into list boxes
global nuts

if size(nuts.meg.goodchannels,2) == 1
   nuts.meg.goodchannels = nuts.meg.goodchannels';
end
nuts.meg.goodchannels = sort(nuts.meg.goodchannels);

if strcmp(get(hObject,'Tag'),'goodchannel_list')
   if isfield(nuts.meg,'sensor_labels')
      set(hObject,'String',nuts.meg.sensor_labels(nuts.meg.goodchannels));
   else
      set(hObject,'String',convert_cell(nuts.meg.goodchannels));
   end
else % badchannel
   badchannels = good2bad(size(nuts.meg.data,2),nuts.meg.goodchannels);
   if isfield(nuts.meg,'sensor_labels')
      set(hObject,'String',nuts.meg.sensor_labels(badchannels));
   else
      set(hObject,'String',convert_cell(badchannels));
   end
end

return

%%-------------------------------------------
function out = convert_cell(inp)
% convert doubles into cells

for i = 1:length(inp)
   out{i} = inp(i);
end

if length(inp) == 0
   out{1} = [];
end

return

%%-------------------------------------------
function nut_amplitude_Callback(hObject,eventdata,handles)
% change colormap and redraw image

if strcmp(get(hObject,'Tag'),'nut_amplitude_figure') | size(get(handles.nut_beamforming_fig,'colormap'),1) == 1
   if get(handles.nut_amplitude_figure,'Value') == 1 % amplitude map
      % first row should be [0 0 0] (black) and second row should be [1 1 1], white
      c = zeros(4096+2,3); c(2,:) = ones(1,3);
      c((1:2048)+2,1) = (1:-1/2047:0)'; c((2049:4096)+2,3) = (0:1/2047:1)';
      set(handles.nut_beamforming_fig,'Colormap',c);
      set(handles.nut_minvalue,'Enable','on')
   else % power map
      % first row should be [0 0 0] (black) and second row should be [1 1 1], white
      c = [zeros(1,3);ones(1,3);[zeros(200,2) (0:0.5/199:0.5)'];jet(3896)];
      set(handles.nut_beamforming_fig,'Colormap',c);
      set(handles.nut_minvalue,'Enable','off')
   end
end

nut_baseline_Callback(handles.nut_select_button, eventdata, handles);

return

%%-------------------------------------------
function plot_bfield(hObject,eventdata,handles)
% draw image showing strength of magnetic field
global nuts bolts

meg = bolts.meg;

time1 = dsearchn(nuts.meg.latency,str2double(get(handles.nut_time1_cs_text,'String')));
time2 = dsearchn(nuts.meg.latency,str2double(get(handles.nut_time2_cs_text,'String')));
ndx = time1:time2;

%%%% huh? what's all this, then?
% nuts.meg.sensorCoord_two_dim = out;
%%%%%%%%%%%%

% initialize
L = bolts.plot_bfield.resolution + 2*bolts.plot_bfield.border;
radius = 0.95*(L+1)/2; % radius of circle that represents head
image_matrix = zeros(L); % create empty image
cmap_length = size(get(handles.nut_beamforming_fig,'colormap'),1);

% row indices where sensors lie (in 2-d image space)
row = round((bolts.plot_bfield.resolution-1)*(bolts.plot_bfield.out(:,1)+bolts.plot_bfield.max_value1)/(2*bolts.plot_bfield.max_value1)) + 1 + bolts.plot_bfield.border;
col = round((bolts.plot_bfield.resolution-1)*(bolts.plot_bfield.out(:,2)+bolts.plot_bfield.max_value2)/(2*bolts.plot_bfield.max_value2)) + 1 + bolts.plot_bfield.border;

% ensure sensors lie in circle (that represents the head) - fix needed for BTI sensors
sensor_radii = sqrt(((L+1)/2-row).^2 + ((L+1)/2-col).^2);
if max(sensor_radii) > radius
   bolts.plot_bfield.out = bolts.plot_bfield.out*0.95*radius/max(sensor_radii);
   row = round((bolts.plot_bfield.resolution-1)*(bolts.plot_bfield.out(:,1)+bolts.plot_bfield.max_value1)/(2*bolts.plot_bfield.max_value1)) + 1 + bolts.plot_bfield.border;
   col = round((bolts.plot_bfield.resolution-1)*(bolts.plot_bfield.out(:,2)+bolts.plot_bfield.max_value2)/(2*bolts.plot_bfield.max_value2)) + 1 + bolts.plot_bfield.border;
end

% define indices
sensor_ndx_good = (col(nuts.meg.goodchannels)-1).*(size(image_matrix,1)) + row(nuts.meg.goodchannels);
sensor_ndx = (col-1).*(size(image_matrix,1)) + row;

if size(meg,2) >= 2
   minvalue = convertunits(handles,get(handles.nut_minvalue,'String'),1,ndx);
   maxvalue = convertunits(handles,get(handles.nut_maxvalue,'String'),0,ndx);
   
   % create image (1 is black, 2 is white, the rest are defined in nut_amplitude_Callback)
   if get(handles.nut_amplitude_figure,'Value') == 1 % amplitude map
       meandata = mean(meg,3); % for unaveraged data
      meandata = mean(meandata(ndx,:),1);
      f = find(meandata < minvalue); meandata(f) = minvalue; % introduce user-specified clipping
      f = find(meandata > maxvalue); meandata(f) = maxvalue;
      f = find(meandata < 0); f2 = find(meandata >= 0);
      meandata(f) = meandata(f)/(2*abs(minvalue)); % -0.5 to 0 are for negative meg values
      meandata(f2) = meandata(f2)/(2*abs(maxvalue)); % 0 to 0.5 are for positive meg values
      image_matrix(sensor_ndx_good) = meandata; % output takes values between -0.5 and 0.5
   else % power map
      meandata = mean(meg(ndx,:).^2,1);
      f = find(meandata > maxvalue^2); meandata(f) = maxvalue^2; % introduce user-specified clipping
      meandata = meandata/maxvalue^2;
      % uses exponential warping for power map
      image_matrix(sensor_ndx_good) = 1-exp(-20*meandata); % output takes values between 0 and 1
   end
   image_matrix = fliplr(flipud(image_matrix));

   % smooth image
   maxnum = max(max(image_matrix));
   minnum = min(min(image_matrix));
   b = exp(-[-2:0.1:2].^2)'*exp(-[-2:0.1:2].^2);
   image_matrix = filter2(b,image_matrix);
   f = find(image_matrix < 0); f2 = find(image_matrix > 0);
   if get(handles.nut_amplitude_figure,'Value') == 1 % amplitude map
      minnum_new = min(min(image_matrix));
      if minnum_new == 0, minnum_new = eps; end
      image_matrix(f) = image_matrix(f)*abs(minnum/minnum_new); % restore previous minimum
   end
   image_matrix(f2) = image_matrix(f2)*maxnum/max(max(image_matrix)); % restore previous maximum
end

% compute x and y indices of image
xstep = 2*bolts.plot_bfield.max_value1/(size(image_matrix,1) - 2*bolts.plot_bfield.border - 1);
ystep = 2*bolts.plot_bfield.max_value2/(size(image_matrix,2) - 2*bolts.plot_bfield.border - 1);
xndx = (-bolts.plot_bfield.max_value1 - 2*xstep):xstep:(bolts.plot_bfield.max_value1 + 2*xstep);
yndx = (-bolts.plot_bfield.max_value2 - 2*ystep):ystep:(bolts.plot_bfield.max_value2 + 2*ystep);
   
% adjust values of amplitude map
if get(handles.nut_amplitude_figure,'Value') == 1 % amplitude map
   image_matrix = image_matrix + 0.5; % output takes values between 0 and 1
end
   
% adjust values for size of colormap
image_matrix = round((cmap_length-3)*image_matrix) + 3; % avoid first 2 rows!

% find indices of region lying outside of circle
f2 = [];
for i = 1:L
   f = find(((1:L)-(L+1)/2).^2 + (i-(L+1)/2)^2 > radius^2);
   f2 = [f2 f+L*(i-1)];
end

% remove portion outside of circle
image_matrix(f2) = 2; % makes area outside of circle white

axes(handles.nut_select_axes)
%c = colormap;set(handles.nut_beamforming_fig,'Colormap',c);
%lh = get(handles.nut_select_axes,'Children');
%lh = handles.sensor_locations;
%if isempty(lh) || ~strcmp(lower(get(lh(end),'Type')),'image') % if the last line handle is not of type image
if ~isfield(handles,'bf_image')
   handles.bf_image = image(xndx,yndx,image_matrix);
   guidata(hObject,handles);
   set(handles.nut_select_axes,'XTick',[],'XTickLabel','','YTick',[],'YTickLabel','');
   a = axis; text(a(2)+0.04*(a(2)-a(1)),a(3)+0.44*(a(4)-a(3)),' Right','Rotation',270);
   title('Anterior'); ylabel('  Left'); xlabel('Posterior'); % title and axis labels must occur after text command above
   %lh = get(handles.nut_select_axes,'Children');
else
   %set(lh(end),'XData',xndx,'YData',yndx,'CData',image_matrix)
   set(handles.bf_image,'XData',xndx,'YData',yndx,'CData',image_matrix)
end

% plot circles for the sensor locations, if ismember then the circles must be redrawn
if ismember(hObject,[handles.nut_select_button handles.nut_deselect_button handles.nut_redeem handles.nut_renounce handles.nut_load_channels_button])
   %delete(lh(1:end-5)); % delete previous circles (the last 2 children are the text "Right" and the image)
   if isfield(handles,'sensor_locations')
      delete(handles.sensor_locations);
   end
   hold on
   
   % fast way, but can't assign unique context menus
   %       h=plot(-bolts.plot_bfield.out	(:,2),-bolts.plot_bfield.out	(:,1),'ow');
   
   % slow way -- gives you context menus
   lh_sensor_locations = zeros(size(nuts.meg.sensor_labels,2),1);
   for i=1:size(nuts.meg.sensor_labels,2)%(bolts.plot_bfield.out	,1)
      sensorui=uicontextmenu;
      item1=uimenu(sensorui,'Label',nuts.meg.sensor_labels{i},'Enable','off');
      togglecmd = ['nut_beamforming_gui(''nut_toggle_channel'',gcbo,[],guidata(gcbf),' num2str(i) ')'];
      if(ismember(i,nuts.meg.goodchannels))
         item2=uimenu(sensorui,'Label','Deselect','Callback',togglecmd,'Tag','nut_sensor_locations');
         % this is too slow to make the ButtonDownFcn practical...
         %  plot(-bolts.plot_bfield.out(i,2),-bolts.plot_bfield.out(i,1),'ow','UIContextMenu',sensorui,'ButtonDownFcn',togglecmd);
%         lh_sensor_locations(i) = plot(-bolts.plot_bfield.out(i,2),-bolts.plot_bfield.out(i,1),'ow','UIContextMenu',sensorui,'Visible','off');
         lh_sensor_locations(i) = plot(-bolts.plot_bfield.out(i,2),-bolts.plot_bfield.out(i,1),'ow','UIContextMenu',sensorui);
%          lh_sensor_locations(i) = plot(-bolts.plot_bfield.out(i,2),-bolts.plot_bfield.out(i,1),'owi','UIContextMenu',sensorui); %for making circles invisible
      else
         item2=uimenu(sensorui,'Label','Select','Callback',['nut_beamforming_gui(''nut_toggle_channel'',gcbo,[],guidata(gcbf),' num2str(i) ')'],'Tag','nut_sensor_locations');
         % this is too slow to make the ButtonDownFcn practical...
         % plot(-bolts.plot_bfield.out(i,2),-bolts.plot_bfield.out(i,1),'o','Color',[0.2 0.2 0.2],'UIContextMenu',sensorui,'ButtonDownFcn',togglecmd);
         lh_sensor_locations(i) = plot(-bolts.plot_bfield.out(i,2),-bolts.plot_bfield.out(i,1),'o','Color',[0.2 0.2 0.2],'UIContextMenu',sensorui);
      end
   end
   
   hold off
   handles.sensor_locations = lh_sensor_locations;
   guidata(hObject,handles);
end

return

function nut_lasso_channels(hObject,eventdata,handles)
% stub for lassoing channels for selection/deselection
[crap,x,y]=roipoly(handles);
select = inpolygon(channelx,channely,x,y);



%%-------------------------------------------
function nut_toggle_channel(hObject,eventdata,handles,chan_num)
% toggle channels between active/unactive using mouse
global nuts

badchannels = good2bad(size(nuts.meg.data,2),nuts.meg.goodchannels);

if ismember(chan_num,nuts.meg.goodchannels) % turn channel off
   f = find(nuts.meg.goodchannels==chan_num);
   ndx = get(handles.goodchannel_list,'Value');
   if min(ndx) >= 1 && max(ndx) <= length(nuts.meg.goodchannels)
      good_length = length(nuts.meg.goodchannels) - 1;
      if good_length ~= 0
         set(handles.goodchannel_list,'Value',min([min(ndx) good_length]));
      end
   end
   nuts.meg.goodchannels(f) = [];
else
   ndx = get(handles.badchannel_list,'Value');
   if min(ndx) >= 1 && max(ndx) <= length(badchannels)
      bad_length = length(badchannels) - 1;
      if bad_length ~= 0
         set(handles.badchannel_list,'Value',min([min(ndx) bad_length]));
      end
   end
   nuts.meg.goodchannels = sort([chan_num nuts.meg.goodchannels]); % turn channel on
end
badchannels = good2bad(size(nuts.meg.data,2),nuts.meg.goodchannels);

set(handles.goodchannel_list,'String',nuts.meg.sensor_labels(nuts.meg.goodchannels));
set(handles.badchannel_list,'String',nuts.meg.sensor_labels(badchannels));
nut_baseline_Callback(handles.nut_redeem, eventdata, handles) % nut_redeem is meaningless

return




%%-------------------------------------------
function num = convertunits(handles,inp,min_flg,timendx)
% convert string 'inp' to number 'out' (if 'inp' is not empty)
% update nut_minvalue/nut_maxvalue strings (if 'inp' is empty)
global bolts

f = find(inp) == ' ';
inp(f) = [];

if isempty(inp) || get(handles.nut_fixlimits,'value') == 0
   if isempty(inp) && get(handles.nut_fixlimits,'value') == 1
      timendx = 1:size(bolts.meg,1); % use entire data set
   end
   
   if min_flg
      num = mean(min(bolts.meg(timendx,:))) + (min(min(bolts.meg(timendx,:))) - mean(min(bolts.meg(timendx,:))))*0.5;
   else
      num = mean(max(bolts.meg(timendx,:))) + (max(max(bolts.meg(timendx,:))) - mean(max(bolts.meg(timendx,:))))*0.5;
   end
      
   exponents = [1e18 1e15 1e12 1e9 1e6 1e3 1e-3 1e-6 1e-9 1e-12 1e-15 1e-18];
   expstring = 'EPTGMKmunpfa';

   [val,pos] = min(abs(abs(num) - exponents));
   numstring = [num2str(round(num/exponents(pos)*100)/100) expstring(pos)];

   if min_flg
      set(handles.nut_minvalue,'String',numstring);
   else
      set(handles.nut_maxvalue,'String',numstring);
   end
else
   if inp(end) == 'E'
      num = str2num(inp(1:end-1))*10^(18);
   elseif inp(end) == 'P'
      num = str2num(inp(1:end-1))*10^(15);
   elseif inp(end) == 'T'
      num = str2num(inp(1:end-1))*10^(12);
   elseif inp(end) == 'G'
      num = str2num(inp(1:end-1))*10^(9);
   elseif inp(end) == 'M'
      num = str2num(inp(1:end-1))*10^(6);
   elseif inp(end) == 'K'
      num = str2num(inp(1:end-1))*10^(3);
   elseif inp(end) == 'm'
      num = str2num(inp(1:end-1))*10^(-3);
   elseif inp(end) == 'u'
      num = str2num(inp(1:end-1))*10^(-6);
   elseif inp(end) == 'n'
      num = str2num(inp(1:end-1))*10^(-9);
   elseif inp(end) == 'p'
      num = str2num(inp(1:end-1))*10^(-12);
   elseif inp(end) == 'f'
      num = str2num(inp(1:end-1))*10^(-15);
   elseif inp(end) == 'a'
      num = str2num(inp(1:end-1))*10^(-18);
   elseif ~isempty(str2num(inp(end)))
      num = str2num(inp(1:end));
   else
      error('Invalid suffix')
   end
end

return

%%-------------------------------------------
function out = good2bad(num_channels,goodchannels)
% convert good channels to bad channels
out = 1:num_channels;
out(goodchannels) = [];

return

%%-------------------------------------------
function nut_plot_eigen(hObject,eventdata,handles)
% plots eigenvectors of autocorrelation/covariance matrix
% this requires bolts.meg to be up to date
% this does *not* update bolts.params.Rzz1, bolts.params.q, etc.

global nuts bolts 

time1 = str2num(get(handles.nut_time1_cs_text,'String'));
time2 = str2num(get(handles.nut_time2_cs_text,'String'));
signalspace = str2num(get(handles.nut_signalspace_text,'String'));
if (size(signalspace,2)==1)
   signalspace = signalspace'; % code doesn't like column vectors
   set(handles.nut_signalspace_text,'String',num2str(signalspace))
end

timept1 = dsearchn(nuts.meg.latency,time1);
timept2 = dsearchn(nuts.meg.latency,time2);

nuts.preprocessing.avecov = get(handles.nut_avecov_box,'Value');
bolts.flags.avecov=nuts.preprocessing.avecov;
[Rzz1,mineigUnave]=nut_cov(bolts.meg(timept1:timept2,:,:),bolts.flags.avecov);

bolts.params.Rzz1 = Rzz1;
bolts.params.Rzz1_mineigUnave = mineigUnave;
condRzz1 = cond(Rzz1); logcond = fix(log10(condRzz1));
disp(['I just dropped in to see what condition my condition was in: ' num2str(condRzz1,'%0.5g')]);
set(handles.nut_cond_edit,'String',num2str(logcond));
logcond_meaningless = 19; % logcond_meaningless must match cond_meaningless found in nut_generate_beamforming_activations
if logcond >= logcond_meaningless
   set(handles.nut_cond_edit,'BackgroundColor',[1 0 0]);
else
   set(handles.nut_cond_edit,'BackgroundColor',[1 0.93 0.83]);
end

[u,q,v]=svd(Rzz1);
q=diag(q);

semi_plot = get(handles.nut_logplot_box,'Value');
cum_plot = get(handles.nut_cumulative_box,'Value');
view_single = str2num(get(handles.nut_viewsingle_edit,'String'));

axes(bolts.eigen_plot);  % this prevents plot from going into SPM image

% we don't want to plot more than 40 eigenvalues (e.g., there'd be 275 for CTF data!)
qmax = min(40,length(q));
if semi_plot & cum_plot
   semilogy(cumsum(q(1:qmax))/sum(q)*100,'o-')
elseif semi_plot & ~cum_plot
   semilogy(q(1:qmax)/sum(q)*100,'o-')
elseif ~semi_plot & cum_plot
   plot(cumsum(q(1:qmax))/sum(q)*100,'o-')
elseif ~semi_plot & ~cum_plot
   plot(q(1:qmax)/sum(q)*100,'o-')
end
xlabel('Eigenspectrum'); ylabel('% of Total');

if view_single == 0
   set(handles.nut_inset_axes,'Visible','off')
else
   axes(handles.nut_inset_axes)
   if cum_plot
      set(handles.nut_inset_axes,'Position',[113 20 25 10].*[6 12 6 12])
   else
      set(handles.nut_inset_axes,'Position',[113 24 25 10].*[6 12 6 12])
   end
   y = bolts.evoked(timept1:timept2,:,:)*v(:,view_single);
   plot(nuts.meg.latency(timept1:timept2),y), axis tight, xlabel('Time (ms)')
   set(handles.nut_inset_axes,'Visible','on')
end

return;

%%-------------------------------------------
function nut_plot_sefa(hObject,eventdata,handles)
% plots eigenvectors of autocorrelation/covariance matrix
% this requires bolts.meg to be up to date
% this does *not* update bolts.params.Rzz1, bolts.params.q, etc.

global nuts bolts

time1 = str2num(get(handles.nut_time1_cs_text,'String'));
time2 = str2num(get(handles.nut_time2_cs_text,'String'));
timept1 = dsearchn(nuts.meg.latency,time1);
timept2 = dsearchn(nuts.meg.latency,time2);
ptime1 = str2num(get(handles.nut_ptime1_cs_text,'String'));
ptime2 = str2num(get(handles.nut_ptime2_cs_text,'String'));
ptimept1 = dsearchn(nuts.meg.latency,ptime1);
ptimept2 = dsearchn(nuts.meg.latency,ptime2);
avecov=get(handles.nut_avecov_box,'Value');

viewsefa = str2num(get(handles.nut_viewsefa_text,'String'));
if length(viewsefa)<2
   set(handles.nut_inset2_axes,'Visible','off')
   set(handles.nut_inset3_axes,'Visible','off')
else
    
    [y_clean,cleaning,www,cy,sig,cyall] = nut_sefa_wrap(bolts.meg,viewsefa(1),viewsefa(2),[timept1 timept2],[ptimept1 ptimept2],avecov);

    axes(bolts.eigen_plot);  % this prevents plot from going into SPM image

    % xlabel('SEFA output');
    % ylabel('% of Total');

    axes(handles.nut_inset2_axes)
    set(handles.nut_inset2_axes,'Position',[116 24 22 10].*[6 12 6 12])
    x = www*(mean(bolts.meg,3))';

    plot(nuts.meg.latency,x), axis tight, xlabel('Time (ms)')
   set(handles.nut_inset2_axes,'Visible','on')

   axes(handles.nut_inset3_axes)
   set(handles.nut_inset3_axes,'Position',[90 24 22 10].*[6 12 6 12])
   plot(nuts.meg.latency,y_clean), axis tight, xlabel('Time (ms)')
   set(handles.nut_inset3_axes,'Visible','on')
end

return;

%%-------------------------------------------
function nut_save_channels_Callback(hObject,eventdata,handles)
% saves current channel selection

[channeldata_filename, channeldata_path] = uiputfile('*.mat','Save channel information to file','channels.mat');
if isequal(channeldata_filename,0) | isequal(channeldata_path,0)
   return;
end

global nuts

data = nuts.meg.goodchannels;
save([channeldata_path channeldata_filename],'data')

return

%%-------------------------------------------
function nut_load_channels_Callback(hObject,eventdata,handles)
% loads current channel selection

[channeldata_filename, channeldata_path] = uigetfile('*.mat','Load channel information from file','channels.mat');
if isequal(channeldata_filename,0) | isequal(channeldata_path,0)
   return;
end

global nuts
load([channeldata_path channeldata_filename])
nuts.meg.goodchannels = data;

badchannels = good2bad(size(nuts.meg.data,2),nuts.meg.goodchannels);

set(handles.goodchannel_list,'String',nuts.meg.sensor_labels(nuts.meg.goodchannels));
set(handles.badchannel_list,'String',nuts.meg.sensor_labels(badchannels));

nut_baseline_Callback(handles.nut_load_channels_button, eventdata, handles)

return

function nut_champ_Callback(hObject,eventdata,handles)
% changes champagne option(s)

global bolts

if handles.nem_ch==hObject
    bolts.flags.champ.nem_ch=str2num(get(hObject,'String'));
elseif handles.multf==hObject
    bolts.flags.champ.multf = str2num(get(hObject,'String'));
else
    disp('how did you get here?')
end



return


%%-------------------------------------------
% --- Creates and returns a handle to the GUI figure. 
function h1 = nut_beamforming_gui_LayoutFcn(policy)
% policy - create a new figure or use a singleton. 'new' or 'reuse'.
global nuts bolts

[gui_obj,gui_fig] = gcbo;

if ~isempty(gui_obj)
   bf_flg = strcmp(get(gui_obj,'Tag'),'nut_beamforming_button'); % 1 for Beamformer Tool, 0 for Channel Selection Tool
else
   bf_flg = 0;
end

%persistent hsingleton;
%if strcmpi(policy, 'reuse') & ishandle(hsingleton)
%   h1 = hsingleton;
%   return;
%end

% set mcc=false for normal operation
% set mcc=true for compiling NUTMEG
mcc=false;
if(mcc) % alternate code for compiled NUTMEG
    bolts.algorithms{1} = 'Default Beamformer';
    bolts.denoise{1} = 'No denoising';
else
   % inspired by SPM's plugin architecture
   nutmegpath = fileparts(which('nutmeg'));
   beamformerpath = fullfile(nutmegpath,'beamformers');
   pluginfiles = dir(fullfile(beamformerpath,'nut_*.m'));
   if ~isempty(pluginfiles)
      % fprintf('spm_orthviews: Using Plugins in %s\n', pluginpath);
      for k = 1:length(pluginfiles)
         [p pluginname e] = fileparts(pluginfiles(k).name);
         % remove 'nut_' and replace other underscores with a space
         bolts.algorithms{k} = strrep(strrep(pluginname, 'nut_',''),'_',' ');
      end
   end
   
   nutmegpath = fileparts(which('nutmeg'));
   beamformerpath = fullfile(nutmegpath,'denoisers');
   pluginfiles = dir(fullfile(beamformerpath,'nut_*.m'));
   clear ndx
   for i=1:length(pluginfiles)
      ndx(i) = strcmp(pluginfiles(i).name(5),upper(pluginfiles(i).name(5))); % check if first letter following "nut_" is uppercase
   end
   f = find(ndx == 0);
   pluginfiles(f) = []; % remove these files from the list (they must be support functions)
   if ~isempty(pluginfiles)
      % fprintf('spm_orthviews: Using Plugins in %s\n', pluginpath);
      for k = 1:length(pluginfiles)
         [p pluginname e] = fileparts(pluginfiles(k).name);
         % remove 'nut_' and replace other underscores with a space
         bolts.denoise{k} = strrep(strrep(pluginname, 'nut_',''),'_',' ');
      end
   end
end

bolts.invtype{1} = 'tikhonov';
bolts.invtype{2} = 'pinv';
bolts.invtype{3} = 'svdtrunc';
bolts.invtype{4} = 'pseudoinverse';
bolts.invtype{5} = 'bayesian';
bolts.invtype{6} = 'vanilla';
bolts.invtype{7} = 'minEigUnAve';
bolts.invtype{8} = 'none';

for i=0:3
    bolts.flags.champ.axtype{i+1}=i;
end
%%
h1 = figure(...
'Units','pixels',...
'PaperUnits','centimeters',...
'Color',[0.93 0.93 0.92],...
'IntegerHandle','off',...
'InvertHardcopy',get(0,'defaultfigureInvertHardcopy'),...
...%'MenuBar','none',...
'NumberTitle','off',...
'PaperOrientation','landscape',...
'PaperPosition',get(0,'defaultfigurePaperPosition'),...
'PaperSize',[11 8.5],...
'Position',[100 100 880 480],...
'Colormap',[0 0 0],...
'PaperType','<custom>',...
'Renderer','ZBuffer',...
'RendererMode','manual',...
'Resize','off',...
'HandleVisibility','callback',...
'UserData',[]);

set(h1,'Tag','nut_beamforming_fig');

if bf_flg
   set(h1,'Name','Beamformer Tool');
else
   set(h1,'Name','Channel Selection Tool');
end

setappdata(h1, 'GUIDEOptions',struct(...
'active_h', [], ...
'taginfo', struct(...
'figure', 2, ...
'popupmenu', 5, ...
'slider', 3, ...
'pushbutton', 12, ...
'text', 11, ...
'edit', 6, ...
'frame', 2, ...
'axes', 3, ...
'checkbox', 5), ...
'override', 1, ...
'release', 13, ...
'resize', 'none', ...
'accessibility', 'callback', ...
'mfile', 1, ...
'callbacks', 1, ...
'singleton', 1, ...
'syscolorfig', 1, ...
'lastSavedFile', '/home/hild/nutmeg/nut_beamforming_gui.m', ...
'blocking', 0));

h1a = uicontrol(...
'Parent',h1,...
'Units','pixels',...
'Callback','nut_beamforming_gui(''nut_baseline_Callback'',gcbo,[],guidata(gcbo))',...
'BackgroundColor',[0.93 0.81 0.63],...
'FontSize',9,...
'ListboxTop',0,...
'Position',[21 12 4 1.8].*[6 12 6 12],...
'String','<-',...
'Tag','nut_shift_left');


h1b = uicontrol(...
'Parent',h1,...
'BackgroundColor',[0.93 0.81 0.63],...
'Units','pixels',...
'Callback','nut_beamforming_gui(''nut_baseline_Callback'',gcbo,[],guidata(gcbo))',...
'FontSize',9,...
'ListboxTop',0,...
'Position',[25 12 4 1.8].*[6 12 6 12],...
'String','->',...
'Tag','nut_shift_right');


h1c = uicontrol(...
'Parent',h1,...
'BackgroundColor',[0.93 0.93 0.92],...
'Units','pixels',...
'FontSize',9,...
'ListboxTop',0,...
'Position',[40 11.6 8 1.8].*[6 12 6 12],...
'String','Stepsize',...
'Style','text',...
'Interruptible','off');


h1d = uicontrol(...
'Parent',h1,...
'Units','pixels',...
'BackgroundColor',[1 0.93 0.83],...
'Callback','nut_beamforming_gui(''nut_baseline_Callback'',gcbo,[],guidata(gcbo))',...
'FontSize',9,...
'HorizontalAlignment','right',...
'ListboxTop',0,...
'Position',[48 12 7 1.7].*[6 12 6 12],...
'String','50',...
'Style','edit',...
'Tag','nut_shift_stepsize');


h1e = uicontrol(...
'Parent',h1,...
'BackgroundColor',[0.93 0.93 0.92],...
'Units','pixels',...
'FontSize',9,...
'ListboxTop',0,...
'Position',[55 11.6 4 1.8].*[6 12 6 12],...
'String','ms',...
'Style','text',...
'Interruptible','off');


h2 = uicontrol(...
'Parent',h1,...
'BackgroundColor',[0.93 0.81 0.63],...
'Units','pixels',...
'Callback','nut_beamforming_gui(''nut_interval_button_Callback'',gcbo,[],guidata(gcbo))',...
'FontSize',9,...
'ListboxTop',0,...
'Position',[37 10 8.4 1.8].*[6 12 6 12],...
'String','active',...
'Tag','nut_interval_button');

h2a = uicontrol(...
'Parent',h1,...
'BackgroundColor',[0.93 0.81 0.63],...
'Units','pixels',...
'Callback','nut_beamforming_gui(''nut_interval_button_Callback'',gcbo,[],guidata(gcbo))',...
'FontSize',9,...
'ListboxTop',0,...
'Position',[2 10 8.4 1.8].*[6 12 6 12],...
'String','control',...
'Tag','nut_interval_button');

h3 = axes(...
'Parent',h1,...
'Units','pixels',...
'CameraPosition',[0.5 0.5 9.16025403784439],...
'CameraPositionMode',get(0,'defaultaxesCameraPositionMode'),...
'Color',get(0,'defaultaxesColor'),...
'ColorOrder',get(0,'defaultaxesColorOrder'),...
'FontSize',9,...
'Position',[13 17 58 20].*[6 12 6 12],...
'XColor',get(0,'defaultaxesXColor'),...
'YColor',get(0,'defaultaxesYColor'),...
'ZColor',get(0,'defaultaxesZColor'),...
'Tag','nut_ts_axes');


h4 = get(h3,'title');

set(h4,...
'Parent',h3,...
'Color',[0 0 0],...
'HorizontalAlignment','center',...
'Position',[0.5 1 1],...
'VerticalAlignment','bottom',...
'HandleVisibility','off');

h5 = get(h3,'xlabel');

set(h5,...
'Parent',h3,...
'Color',[0 0 0],...
'HorizontalAlignment','center',...
'Position',[0.5 -0.1 1],...
'VerticalAlignment','cap',...
'HandleVisibility','off');

h6 = get(h3,'ylabel');

set(h6,...
'Parent',h3,...
'Color',[0 0 0],...
'HorizontalAlignment','center',...
'Position',[-0.07 0.5 1],...
'Rotation',90,...
'VerticalAlignment','bottom',...
'HandleVisibility','off');

h7 = get(h3,'zlabel');

set(h7,...
'Parent',h3,...
'Color',[0 0 0],...
'HorizontalAlignment','right',...
'Position',[-0.22 1 1],...
'HandleVisibility','off',...
'Visible','off');

h8 = uicontrol(...
'Parent',h1,...
'BackgroundColor',[1 0.93 0.83],...
'Units','pixels',...
'Callback','nut_beamforming_gui(''nut_baseline_Callback'',gcbo,[],guidata(gcbo))',...
'FontSize',9,...
'HorizontalAlignment','right',...
'ListboxTop',0,...
'Position',[45.5 10 8.17 1.67].*[6 12 6 12],...
'String','0',...
'Style','edit',...
'Tag','nut_time1_cs_text');

h8a = uicontrol(...
'Parent',h1,...
'BackgroundColor',[1 0.93 0.83],...
'Units','pixels',...
'Callback','nut_beamforming_gui(''nut_baseline_Callback'',gcbo,[],guidata(gcbo))',...
'FontSize',9,...
'HorizontalAlignment','right',...
'ListboxTop',0,...
'Position',[11 10 8.17 1.67].*[6 12 6 12],...
'String','-10',...
'Style','edit',...
'Tag','nut_ptime1_cs_text');

% 'CreateFcn','nut_beamforming_gui(''nut_time1_cs_text_CreateFcn'',gcbo,[],guidata(gcbo))',...


h9 = uicontrol(...
'Parent',h1,...
'BackgroundColor',[1 0.93 0.83],...
'Units','pixels',...
'Callback','nut_beamforming_gui(''nut_baseline_Callback'',gcbo,[],guidata(gcbo))',...
'FontSize',9,...
'HorizontalAlignment','right',...
'ListboxTop',0,...
'Position',[57.33 10 8.17 1.67].*[6 12 6 12],...
'String','0',...
'Style','edit',...
'Tag','nut_time2_cs_text');

h9a = uicontrol(...
'Parent',h1,...
'BackgroundColor',[1 0.93 0.83],...
'Units','pixels',...
'Callback','nut_beamforming_gui(''nut_baseline_Callback'',gcbo,[],guidata(gcbo))',...
'FontSize',9,...
'HorizontalAlignment','right',...
'ListboxTop',0,...
'Position',[22.33 10 8.17 1.67].*[6 12 6 12],...
'String','-5',...
'Style','edit',...
'Tag','nut_ptime2_cs_text');

% 'CreateFcn','nut_beamforming_gui(''nut_time2_cs_text_CreateFcn'',gcbo,[],guidata(gcbo))',...


h10 = uicontrol(...
'Parent',h1,...
'BackgroundColor',[0.93 0.93 0.92],...
'Units','pixels',...
'FontSize',9,...
'ListboxTop',0,...
'Position',[54 10 2.7 1.4].*[6 12 6 12],...
'String','to',...
'Style','text',...
'Interruptible','off',...
'SelectionHighlight','off',...
'Tag','text6');


h11 = uicontrol(...
'Parent',h1,...
'BackgroundColor',[0.93 0.93 0.92],...
'Units','pixels',...
'CData',[],...
'FontSize',9,...
'HorizontalAlignment','left',...
'ListboxTop',0,...
'Position',[66 10 4.83 1.4].*[6 12 6 12],...
'String','ms',...
'Style','text',...
'Interruptible','off',...
'SelectionHighlight','off',...
'Tag','text_ms',...
'UserData',[]);

h11a = uicontrol(...
'Parent',h1,...
'BackgroundColor',[0.93 0.93 0.92],...
'Units','pixels',...
'CData',[],...
'FontSize',9,...
'HorizontalAlignment','left',...
'ListboxTop',0,...
'Position',[31 10 4.83 1.4].*[6 12 6 12],...
'String','ms',...
'Style','text',...
'Interruptible','off',...
'SelectionHighlight','off',...
'Tag','text_ms',...
'UserData',[]);

if bf_flg == 1
   h12 = axes(...
      'Parent',h1,...
      'Units','pixels',...
      'CameraPosition',[0.5 0.5 9.2],...
      'CameraPositionMode',get(0,'defaultaxesCameraPositionMode'),...
      'Color',get(0,'defaultaxesColor'),...
      'ColorOrder',get(0,'defaultaxesColorOrder'),...
      'FontSize',9,...
      'Position',[82 17 58 20].*[6 12 6 12],...
      'XColor',get(0,'defaultaxesXColor'),...
      'YColor',get(0,'defaultaxesYColor'),...
      'ZColor',get(0,'defaultaxesZColor'));
   
   set(h12,'Tag','nut_eigen_axes');
   
   h12b = axes(...
      'Parent',h1,...
      'Units','pixels',...
      'CameraPosition',[0.5 0.5 9.2],...
      'CameraPositionMode',get(0,'defaultaxesCameraPositionMode'),...
      'Color',get(0,'defaultaxesColor'),...
      'ColorOrder',get(0,'defaultaxesColorOrder'),...
      'FontSize',9,...
      'Visible','off',...
      'XColor',get(0,'defaultaxesXColor'),...
      'YColor',get(0,'defaultaxesYColor'),...
      'ZColor',get(0,'defaultaxesZColor'),...
      'Tag','nut_inset_axes');
   h12c = axes(...
      'Parent',h1,...
      'Units','pixels',...
      'CameraPosition',[0.5 0.5 9.2],...
      'CameraPositionMode',get(0,'defaultaxesCameraPositionMode'),...
      'Color',get(0,'defaultaxesColor'),...
      'ColorOrder',get(0,'defaultaxesColorOrder'),...
      'FontSize',9,...
      'Visible','off',...
      'XColor',get(0,'defaultaxesXColor'),...
      'YColor',get(0,'defaultaxesYColor'),...
      'ZColor',get(0,'defaultaxesZColor'),...
      'Tag','nut_inset2_axes');
   h12d = axes(...
      'Parent',h1,...
      'Units','pixels',...
      'CameraPosition',[0.5 0.5 9.2],...
      'CameraPositionMode',get(0,'defaultaxesCameraPositionMode'),...
      'Color',get(0,'defaultaxesColor'),...
      'ColorOrder',get(0,'defaultaxesColorOrder'),...
      'FontSize',9,...
      'Visible','off',...
      'XColor',get(0,'defaultaxesXColor'),...
      'YColor',get(0,'defaultaxesYColor'),...
      'ZColor',get(0,'defaultaxesZColor'),...
      'Tag','nut_inset3_axes');
else
   h12 = axes(...
      'Parent',h1,...
      'Units','pixels',...
      'CameraPosition',[0.5 0.5 9.2],...
      'CameraPositionMode',get(0,'defaultaxesCameraPositionMode'),...
      'Color',get(0,'defaultaxesColor'),...
      'ColorOrder',get(0,'defaultaxesColorOrder'),...
      'FontSize',9,...
      'Position',[82 17 45 20].*[6 12 6 12],...
      'XTickLabelMode','manual',...
      'XTickMode','manual',...
      'YTickLabelMode','manual',...
      'YTickMode','manual',...
      'Tag','nut_select_axes');
   
   set(h12,'Tag','nut_select_axes');
end


h21b = uicontrol(...
'Parent',h1,...
'BackgroundColor',[0.8 0.7 0.54],...
'Units','pixels',...
'FontSize',9,...
'Position',[18 2.3 41.5 7.0].*[6 12 6 12],...
'Style','frame');


h22 = uicontrol(...
'Parent',h1,...
'BackgroundColor',[0.93 0.81 0.63],...
'Units','pixels',...
'Callback','nut_beamforming_gui(''nut_baseline_Callback'',gcbo,[],guidata(gcbo))',...
'FontSize',9,...
'ListboxTop',0,...
'Position',[19 7 23 1.8].*[6 12 6 12],...
'String',{'No baseline correction'; 'Remove DC offset'; 'Linear detrend' },...
'Style','popupmenu',...
'Value',1,...
'Tag','nut_baseline');

% 'CreateFcn','nut_beamforming_gui(''nut_baseline_CreateFcn'',gcbo,[],guidata(gcbo))',...

h22b = uicontrol(...
'Parent',h1,...
'BackgroundColor',[0.93 0.81 0.63],...
'Units','pixels',...
'FontSize',9,...
'ListboxTop',0,...
'Position',[19 3 18 1.8].*[6 12 6 12],...
'Callback','nut_beamforming_gui(''nut_baseline_Callback'',gcbo,[],guidata(gcbo))',...
'String','Bandpass Filter',...
'Style','checkbox',...
'Tag','nut_bpf');

ver_temp = version;
if ver_temp(1) == '6' % ver 6 includes a frame around checkboxes, ver 7 does not
   set(h22b,'BackgroundColor',[0.93 0.81 0.63]);
else % version 7 assumed
   set(h22b,'BackgroundColor',[0.8 0.7 0.54]);
end

h22c = uicontrol(...
'Parent',h1,...
'BackgroundColor',[1 0.93 0.83],...
'CData',[],...
'Units','pixels',...
'HorizontalAlignment','right',...
'FontSize',9,...
'ListboxTop',0,...
'Callback','nut_beamforming_gui(''nut_baseline_Callback'',gcbo,[],guidata(gcbo))',...
'Position',[40.5 3 5 1.7].*[6 12 6 12],...
'String','',...
'Style','edit',...
'Tag','nut_bpf_low_cutoff');


h22d = uicontrol(...
'Parent',h1,...
'BackgroundColor',[0.8 0.7 0.54],...
'CData',[],...
'Units','pixels',...
'HorizontalAlignment','left',...
'FontSize',9,...
'ListboxTop',0,...
'Position',[45.5 2.6 3 1.8].*[6 12 6 12],...
'String','to',...
'SelectionHighlight','off',...
'Style','text');


h22e = uicontrol(...
'Parent',h1,...
'BackgroundColor',[1 0.93 0.83],...
'CData',[],...
'Units','pixels',...
'HorizontalAlignment','right',...
'FontSize',9,...
'ListboxTop',0,...
'Callback','nut_beamforming_gui(''nut_baseline_Callback'',gcbo,[],guidata(gcbo))',...
'Position',[48.5 3 7 1.7].*[6 12 6 12],...
'String','',...
'Style','edit',...
'Tag','nut_bpf_high_cutoff');


h22f = uicontrol(...
'Parent',h1,...
'BackgroundColor',[0.8 0.7 0.54],...
'CData',[],...
'Units','pixels',...
'HorizontalAlignment','left',...
'FontSize',9,...
'ListboxTop',0,...
'Position',[55.5 2.6 3.5 1.8].*[6 12 6 12],...
'String','Hz',...
'SelectionHighlight','off',...
'Style','text');


h22g = uicontrol(...
'Parent',h1,...
'Units','pixels',...
'BackgroundColor',[0.93 0.81 0.63],...
'Callback','nut_beamforming_gui(''nut_baseline_Callback'',gcbo,[],guidata(gcbo))',...
'FontSize',9,...
'ListboxTop',0,...
'Position',[19 5 23 1.8].*[6 12 6 12],...
'String',{'No notch filter'; '50 Hz notch'; '60 Hz notch' },...
'Style','popupmenu',...
'Value',1,...
'Tag','nut_notch');


%ver_temp = version;
%if ver_temp(1) == '6' % ver 6 includes a frame around checkboxes, ver 7 does not
%   set(h22h,'BackgroundColor',[0.93 0.81 0.63]);
%else % version 7 assumed
%   set(h22h,'BackgroundColor',[0.8 0.7 0.54]);
%end

if bf_flg == 1 % open beamformer tool
   h13 = get(h12,'title');
   
   set(h13,...
      'Parent',h12,...
      'Color',[0 0 0],...
      'HorizontalAlignment','center',...
      'Position',[0.5 1 1],...
      'VerticalAlignment','bottom',...
      'HandleVisibility','off');
   
   h14 = get(h12,'xlabel');
   
   set(h14,...
      'Parent',h12,...
      'Color',[0 0 0],...
      'HorizontalAlignment','center',...
      'Position',[0.5 -0.1 1],...
      'VerticalAlignment','cap',...
      'HandleVisibility','off');
   
   h15 = get(h12,'ylabel');
   
   set(h15,...
      'Parent',h12,...
      'Color',[0 0 0],...
      'HorizontalAlignment','center',...
      'Position',[-0.07 0.49 1],...
      'Rotation',90,...
      'VerticalAlignment','bottom',...
      'HandleVisibility','off');
   
   h16 = get(h12,'zlabel');
   
   set(h16,...
      'Parent',h12,...
      'Color',[0 0 0],...
      'HorizontalAlignment','right',...
      'Position',[-1.4 1.06 1],...
      'HandleVisibility','off',...
      'Visible','off');
   
   h16a = uicontrol(...
      'Parent',h1,...
      'BackgroundColor',[0.93 0.93 0.92],...
      'Units','pixels',...
      'CData',[],...
      'FontSize',9,...
      'HorizontalAlignment','center',...
      'ListboxTop',0,...
      'Position',[65 8.5 15 1.5].*[6 12 6 12],...
      'String','Log condition',...
      'Style','text',...
      'Interruptible','off',...
      'SelectionHighlight','off',...
      'Tag','nut_cond_text',...
      'UserData',[]);
   
   h16b = uicontrol(...
      'Parent',h1,...
      'BackgroundColor',[0.93 0.93 0.92],...
      'Units','pixels',...
      'CData',[],...
      'FontSize',9,...
      'HorizontalAlignment','center',...
      'ListboxTop',0,...
      'Position',[65 7.5 15 1.5].*[6 12 6 12],...
      'String','number',...
      'Style','text',...
      'Interruptible','off',...
      'SelectionHighlight','off',...
      'Tag','nut_cond_text',...
      'UserData',[]);

   h16c = uicontrol(...
      'Parent',h1,...
      'BackgroundColor',[1 0.93 0.83],...
      'Units','pixels',...
      'CData',[],...
      'FontSize',20,...
      'HorizontalAlignment','center',...
      'ListboxTop',0,...
      'Position',[67.7 5 9 2.8].*[6 12 6 12],...
      'String','',...
      'Style','edit',...
      'Tag','nut_cond_edit',...
      'UserData',[]);
   
   h17 = uicontrol(...
      'Parent',h1,...
      'BackgroundColor',[1 0.93 0.83],...
      'Units','pixels',...
      'Callback','nut_beamforming_gui(''nut_plot_eigen'',gcbo,[],guidata(gcbo))',...
      'CData',[],...
      'FontSize',9,...
      'HorizontalAlignment','right',...
      'ListboxTop',0,...
      'Position',[128 10.75 11 1.5].*[6 12 6 12],...
      'String','3',...
      'Style','edit',...
      'Tag','nut_signalspace_edit',...
      'UserData',[]);

   %       'CreateFcn','nut_beamforming_gui(''nut_signalspace_text_CreateFcn'',gcbo,[],guidata(gcbo))',...

   
   h17b = uicontrol(...
      'Parent',h1,...
      'BackgroundColor',[1 0.93 0.83],...
      'Units','pixels',...
      'Callback','nut_beamforming_gui(''nut_plot_eigen'',gcbo,[],guidata(gcbo))',...
      'CData',[],...
      'FontSize',9,...
      'HorizontalAlignment','right',...
      'ListboxTop',0,...
      'Position',[128 12.5 11 1.5].*[6 12 6 12],...
      'String','0',...
      'Style','edit',...
      'Tag','nut_viewsingle_edit',...
      'UserData',[]);

     h17d = uicontrol(...
      'Parent',h1,...
      'BackgroundColor',[1 0.93 0.83],...
      'Units','pixels',...
      'Callback','nut_beamforming_gui(''nut_plot_sefa'',gcbo,[],guidata(gcbo))',...
      'CData',[],...
      'FontSize',9,...
      'HorizontalAlignment','right',...
      'ListboxTop',0,...
      'Position',[137 5 8 1.5].*[6 12 6 12],...
      'String','0',...
      'Style','edit',...
      'Tag','nut_viewsefa_text',...
      'UserData',[]);

     h17e = uicontrol(...
      'Parent',h1,...
      'BackgroundColor',[1 0.93 0.83],...
      'Units','pixels',...
      'Callback','nut_beamforming_gui(''nut_plot_sefa'',gcbo,[],guidata(gcbo))',...
      'CData',[],...
      'FontSize',9,...
      'HorizontalAlignment','right',...
      'ListboxTop',0,...
      'Position',[132 9 8 1.5].*[6 12 6 12],...
      'String','15',...
      'Style','edit',...
      'Tag','nut_nm_edit',...
      'UserData',[]);

   h17c = uicontrol(...
      'Parent',h1,...
      'Units','pixels',...
      'BackgroundColor',[0.93 0.81 0.63],...
      'FontSize',9,...
      'ListboxTop',0,...
      'Position',[83 5 30 1.8].*[6 12 6 12],...
      'String',bolts.denoise,...
      'Style','popupmenu',...
      'Value',1,...
      'Tag','nut_whichdenoiser');
   
   h18 = uicontrol(...
      'Parent',h1,...
      'Units','pixels',...
      'BackgroundColor',[0.93 0.81 0.63],...
      'FontSize',9,...
      'Callback','nut_beamforming_gui(''nut_select_beamformer'',gcbo,[],guidata(gcbo))',...
      'ListboxTop',0,... band
      'Position',[83 3 30 1.8].*[6 12 6 12],...
      'String',bolts.algorithms,...
      'Style','popupmenu',...
      'Value',1,...
      'Tag','nut_whichbeamformer');

   %       'CreateFcn','nut_beamforming_gui(''nut_whichbeamformer_CreateFcn'',gcbo,[],guidata(gcbo))',...

   
   h19 = uicontrol(...
      'Parent',h1,...
      'BackgroundColor',[0.93 0.81 0.63],...
      'Units','pixels',...
      'Callback','nut_beamforming_gui(''nut_proceed_button_Callback'',gcbo,[],guidata(gcbo))',...
      'FontSize',9,...
      'ListboxTop',0,...
      'Position',[123 3 16 1.8].*[6 12 6 12],...
      'String','Proceed',...
      'Tag','nut_proceed_button');
   
   
   h20 = uicontrol(...
      'Parent',h1,...
      'BackgroundColor',[0.93 0.93 0.92],...
      'Units','pixels',...
      'CData',[],...
      'FontSize',9,...
      'HorizontalAlignment','right',...
      'ListboxTop',0,...
      'Position',[100 10.5 27 1.5].*[6 12 6 12],...
      'String','Eigenvalues for signal space',...
      'Style','text',...
      'Interruptible','off',...
      'SelectionHighlight','off',...
      'Tag','nut_signalspace_text',...
      'UserData',[]);
   
   
   h20b = uicontrol(...
      'Parent',h1,...
      'BackgroundColor',[0.93 0.93 0.92],...
      'Units','pixels',...
      'CData',[],...
      'FontSize',9,...
      'HorizontalAlignment','right',...
      'ListboxTop',0,...
      'Position',[100 12.25 27 1.5].*[6 12 6 12],...
      'String','View single eigenprojection',...
      'Style','text',...
      'Interruptible','off',...
      'SelectionHighlight','off',...
      'Tag','nut_single_eigenproj_text',...
      'UserData',[]);
   
   h20c = uicontrol(...
      'Parent',h1,...
      'BackgroundColor',[0.93 0.93 0.92],...
      'Units','pixels',...
      'CData',[],...
      'FontSize',9,...
      'HorizontalAlignment','right',...
      'ListboxTop',0,...
      'Position',[113 5 23 1.5].*[6 12 6 12],...
      'String','View SEFA: input [nl nm]',...
      'Style','text',...
      'Interruptible','off',...
      'SelectionHighlight','off',...
      'Tag','nut_sefa_nl_nm_text',...
      'UserData',[]);

   h20d = uicontrol(...
      'Parent',h1,...
      'BackgroundColor',[0.93 0.93 0.92],...
      'Units','pixels',...
      'CData',[],...
      'FontSize',9,...
      'HorizontalAlignment','right',...
      'ListboxTop',0,...
      'Position',[123 9 6 1.5].*[6 12 6 12],...
      'String','nm',...
      'Style','text',...
      'Interruptible','off',...
      'SelectionHighlight','off',...
      'Tag','nut_nm_text',...
      'UserData',[]);

  h21 = uicontrol(...
      'Parent',h1,...
      'BackgroundColor',[0.93 0.81 0.63],...
      'Units','pixels',...
      'FontSize',9,...
      'Callback','nut_beamforming_gui(''nut_plot_eigen'',gcbo,[],guidata(gcbo))',...
      'ListboxTop',0,...
      'Position',[83 12.5 16 1.5].*[6 12 6 12],...
      'String','Semilog plot',...
      'Style','checkbox',...
      'Tag','nut_logplot_box');
   
   
   h21b = uicontrol(...
      'Parent',h1,...
      'Units','pixels',...
      'BackgroundColor',[0.93 0.81 0.63],...
      'Callback','nut_beamforming_gui(''nut_plot_eigen'',gcbo,[],guidata(gcbo))',...
      'FontSize',9,...
      'ListboxTop',0,...
      'Position',[83 10.75 16 1.5].*[6 12 6 12],...
      'String','Cumulative Plot',...
      'Style','checkbox',...
      'Tag','nut_cumulative_box');

     h21c = uicontrol(...
      'Parent',h1,...
      'Units','pixels',...
      'BackgroundColor',[0.93 0.81 0.63],...
      'FontSize',9,...
      'ListboxTop',0,...
      'Position',[123 1 16 1.5].*[6 12 6 12],...
      'String','run Qsub',...
      'Style','checkbox',...
      'Tag','nut_qsub_box');
%        'Callback','nut_beamforming_gui(''nut_plot_eigen'',gcbo,[],guidata(gcbo))',...

     h21d = uicontrol(...
      'Parent',h1,...
      'Units','pixels',...
      'BackgroundColor',[0.93 0.81 0.63],...
      'FontSize',9,...
      'ListboxTop',0,...
      'Position',[2 8 16 1.5].*[6 12 6 12],...
      'String','comp control',...
      'Style','checkbox',...
      'Tag','nut_W2_box');

     h21d = uicontrol(...
      'Parent',h1,...
      'Units','pixels',...
      'BackgroundColor',[0.93 0.81 0.63],...
      'Callback','nut_beamforming_gui(''nut_plot_eigen'',gcbo,[],guidata(gcbo))',...
      'FontSize',9,...
      'ListboxTop',0,...
      'Position',[2 6 16 1.5].*[6 12 6 12],...
      'String','ave, then cov',...
      'Style','checkbox',...
      'Tag','nut_avecov_box');


   h25 = uicontrol(...
      'Parent',h1,...
      'Units','pixels',...
      'BackgroundColor',[1 0.93 0.83],...
      'CData',[],...
      'FontSize',9,...
      'HorizontalAlignment','left',...
      'ListboxTop',0,...
      'Position',[83 7.15 56 1.5].*[6 12 6 12],...
      'String',['s_beam_' nuts.meg.filename '.mat'],...
      'Style','edit',...
      'Interruptible','off',...
      'SelectionHighlight','off',...
      'Tag','nut_outname_box',...
      'UserData',[]);
   
   h26 = uicontrol(...
      'Parent',h1,...
      'Units','pixels',...
      'BackgroundColor',[0.93 0.93 0.92],...
      'CData',[],...
      'FontSize',10,...
      'HorizontalAlignment','left',...
      'ListboxTop',0,...
      'Position',[82.8 8.7 18 1.5].*[6 12 6 12],...
      'String','Output filename:',...
      'Style','text',...
      'Interruptible','off',...
      'SelectionHighlight','off',...
      'Tag','text10',...
      'UserData',[]);   
  
   h27 = uicontrol(...
      'Parent',h1,...
      'Units','pixels',...
      'BackgroundColor',[0.93 0.81 0.63],...
      'FontSize',9,...
      'ListboxTop',0,... band
      'Position',[83 1 30 1.8].*[6 12 6 12],...
      'String',bolts.invtype,...
      'Style','popupmenu',...
      'Value',1,...
      'Tag','nut_which_invtype');

   % specify iterations for champagne
   h1170 = uicontrol(...
      'Parent',h1,...
      'BackgroundColor',[1 0.93 0.83],...
      'Units','pixels',...
      'Callback','nut_beamforming_gui(''nut_champ_Callback'',gcbo,[],guidata(gcbo))',...
      'CData',[],...
      'FontSize',9,...
      'HorizontalAlignment','right',...
      'ListboxTop',0,...
      'Position',[768 150 66 18],...
      'String','100',...
      'Style','edit',...
      'Tag','nem_ch',...
      'UserData',[]);

  % label for champagne iterations box
  h1171 = uicontrol(...
    'Parent',h1,...
    'BackgroundColor',[0.93 0.93 0.92],...
    'CData',[],...
    'FontName',get(0,'defaultuicontrolFontName'),...
    'FontSize',9,...
    'HorizontalAlignment','right',...
    'ListboxTop',0,...
    'Position',[562 150 200 19],...
    'String','Number of Champagne iterations',...
    'Style','text',...
    'Interruptible','off',...
    'SelectionHighlight','off',...
    'Tag','nem_label',...
    'UserData',[],...
    'Visible','on');
    
    % which ax type
   h1172 = uicontrol(...
      'Parent',h1,...
      'Units','pixels',...
      'BackgroundColor',[0.93 0.81 0.63],...
      'FontSize',9,...
      'ListboxTop',0,...
      'Position',[768 174 66 18],...
      'String',bolts.flags.champ.axtype,...
      'Style','popupmenu',...
      'Value',1,...
      'Tag','champ_which_ax');
  
    % label for champagne AX box
  h1173 = uicontrol(...
    'Parent',h1,...
    'BackgroundColor',[0.93 0.93 0.92],...
    'CData',[],...
    'FontName',get(0,'defaultuicontrolFontName'),...
    'FontSize',9,...
    'HorizontalAlignment','right',...
    'ListboxTop',0,...
    'Position',[562 174 200 19],...
    'String','AX',...
    'Style','text',...
    'Interruptible','off',...
    'SelectionHighlight','off',...
    'Tag','ax_label',...
    'UserData',[],...
    'Visible','on');

   % specify multf for champagne
   h1174 = uicontrol(...
      'Parent',h1,...
      'BackgroundColor',[1 0.93 0.83],...
      'Units','pixels',...
      'Callback','nut_beamforming_gui(''nut_champ_Callback'',gcbo,[],guidata(gcbo))',...
      'CData',[],...
      'FontSize',9,...
      'HorizontalAlignment','right',...
      'ListboxTop',0,...
      'Position',[768 126 66 18],...
      'String','1',...
      'Style','edit',...
      'Tag','multf',...
      'UserData',[]);

  % label for champagne multf box
  h1175 = uicontrol(...
    'Parent',h1,...
    'BackgroundColor',[0.93 0.93 0.92],...
    'CData',[],...
    'FontName',get(0,'defaultuicontrolFontName'),...
    'FontSize',9,...
    'HorizontalAlignment','right',...
    'ListboxTop',0,...
    'Position',[562 126 200 19],...
    'String','Scalar (multf) used for AX 1 and 3',...
    'Style','text',...
    'Interruptible','off',...
    'SelectionHighlight','off',...
    'Tag','multf_label',...
    'UserData',[],...
    'Visible','on');




  % help text for AX
  h1176 = uicontrol(...
    'Parent',h1,...
    'BackgroundColor',[0.93 0.93 0.92],...
    'CData',[],...
    'FontName',get(0,'defaultuicontrolFontName'),...
    'FontSize',9,...
    'HorizontalAlignment','left',...
    'ListboxTop',0,...
    'Position',[500 300 300 100 ],...
    'String',{'AX 0 is default',...
        'AX 1 is using cleaned post-stim data and uses scalar (multf) times identity for noise',...
        'AX 2 uses only sensor noise learned from SEFA',...
        'AX 3 doesn''t use cleaned data but uses scalar (multf) times identity for noise'},...
    'Style','text',...
    'Interruptible','off',...
    'SelectionHighlight','off',...
    'Tag','champ_help',...
    'UserData',[],...
    'Visible','on');

      
else % open channel selection tool
   
   h100a = uicontrol(...
      'Parent',h1,...
      'BackgroundColor',[0.93 0.93 0.92],...
      'Units','pixels',...
      'FontSize',9,...
      'ListboxTop',0,...
      'HorizontalAlignment','left',...
      'Position',[83 12.5 15 1.8].*[6 12 6 12],...
      'String','Deselected',...
      'Style','text',...
      'Interruptible','off');

   h100b = uicontrol(...
      'Parent',h1,...
      'BackgroundColor',[0.93 0.93 0.92],...
      'Units','pixels',...
      'FontSize',9,...
      'ListboxTop',0,...
      'HorizontalAlignment','left',...
      'Position',[83 11.5 15 1.8].*[6 12 6 12],...
      'String','Channels:',...
      'Style','text',...
      'Interruptible','off');

   h100c = uicontrol(...
      'Parent',h1,...
      'BackgroundColor',[0.93 0.93 0.92],...
      'Units','pixels',...
      'FontSize',9,...
      'ListboxTop',0,...
      'HorizontalAlignment','left',...
      'Position',[80 14.5 60 1].*[6 12 6 12],...
      'String','Right-click on time series or sensor location for more information...',...
      'Style','text',...
      'Interruptible','off');

  h100 = uicontrol(...
      'Parent',h1,...
      'BackgroundColor',[1 0.93 0.83],...
      'Units','pixels',...
      'FontSize',9,...
      'Position',[82 2 11.5 10].*[6 12 6 12],...
      'Style','listbox',...
      'Max',1000,...
      'Value',1,...
      'CreateFcn','nut_beamforming_gui(''nut_loadchannels_CreateFcn'',gcbo,[],guidata(gcbo))',...
      'Tag','badchannel_list');
   
   h101a = uicontrol(...
      'Parent',h1,...
      'BackgroundColor',[0.93 0.93 0.92],...
      'Units','pixels',...
      'FontSize',9,...
      'ListboxTop',0,...
      'HorizontalAlignment','left',...
      'Position',[101 12.5 15 1.8].*[6 12 6 12],...
      'String','Selected',...
      'Style','text',...
      'Interruptible','off');
   
   h101b = uicontrol(...
      'Parent',h1,...
      'BackgroundColor',[0.93 0.93 0.92],...
      'Units','pixels',...
      'FontSize',9,...
      'ListboxTop',0,...
      'HorizontalAlignment','left',...
      'Position',[101 11.5 15 1.8].*[6 12 6 12],...
      'String','Channels:',...
      'Style','text',...
      'Interruptible','off');

   h101 = uicontrol(...
      'Parent',h1,...
      'BackgroundColor',[1 0.93 0.83],...
      'Units','pixels',...
      'Max',1000,...
      'FontSize',9,...
      'Position',[100 2 11.5 10].*[6 12 6 12],...
      'Style','listbox',...
      'Value',1,...
      'CreateFcn','nut_beamforming_gui(''nut_loadchannels_CreateFcn'',gcbo,[],guidata(gcbo))',...
      'Tag','goodchannel_list');
   
   
   h102 = uicontrol(...
      'Parent',h1,...
      'BackgroundColor',[0.93 0.81 0.63],...
      'Units','pixels',...
      'Callback','nut_beamforming_gui(''nut_judge_Callback'',gcbo,[],guidata(gcbo))',...
      'FontSize',9,...
      'ListboxTop',0,...
      'Position',[95 5 4 1.8].*[6 12 6 12],...
      'String','<-',...
      'Tag','nut_renounce');
   
   
   h103 = uicontrol(...
      'Parent',h1,...
      'BackgroundColor',[0.93 0.81 0.63],...
      'Units','pixels',...
      'Callback','nut_beamforming_gui(''nut_judge_Callback'',gcbo,[],guidata(gcbo))',...
      'FontSize',9,...
      'ListboxTop',0,...
      'Position',[95 7 4 1.8].*[6 12 6 12],...
      'String','->',...
      'Tag','nut_redeem');
   
   h104a = uicontrol(...
      'Parent',h1,...
      'BackgroundColor',[0.93 0.93 0.92],...
      'Units','pixels',...
      'FontSize',9,...
      'ListboxTop',0,...
      'HorizontalAlignment','left',...
      'Position',[120 8 20 1.8].*[6 12 6 12],...
      'String','Channel Group:',...
      'Style','text',...
      'Interruptible','off');
   
   h104 = uicontrol(...
      'Parent',h1,...
      'BackgroundColor',[0.93 0.81 0.63],...
      'Units','pixels',...
      'FontSize',9,...
      'ListboxTop',0,...
      'Position',[120 6.5 20 1.8].*[6 12 6 12],...
      'Style','popupmenu',...
      'Value',1,...
      'Tag','nut_select_group');
      
      if isfield(nuts.meg,'sensor_labels')
          if strcmp(nuts.meg.sensor_labels{1}(1),'M')
         set(h104,'String',{'All channels'; 'Left'; 'Right';'Midline';'Frontal';'Parietal';'Occipital';'Temporal';'Central'});
          else
              set(h104,'String',{'All channels'});
          end
      else
         set(h104,'String',{'All channels'; 'Left'; 'Right'});
      end
      
   
%    h105a = uicontrol(...
%       'Parent',h1,...
%       'BackgroundColor',[0.93 0.93 0.92],...
%       'Units','pixels',...
%       'FontSize',9,...
%       'ListboxTop',0,...
%       'HorizontalAlignment','left',...
%       'Position',[120 10 12 1.8].*[6 12 6 12],...
%       'String','Figure:',...
%       'Style','text',...
%       'Interruptible','off');
   
   h105= uicontrol(...
      'Parent',h1,...
      'BackgroundColor',[0.93 0.81 0.63],...
      'Units','pixels',...
      'FontSize',9,...
      'ListboxTop',0,...
      'Callback','nut_beamforming_gui(''nut_amplitude_Callback'',gcbo,[],guidata(gcbo))',...
      'Position',[120 12.7 20 1.8].*[6 12 6 12],...
      'String',{'Amplitude'; 'Power'},...
      'Style','popupmenu',...
      'Visible','off',...
      'Value',1,...
      'Tag','nut_amplitude_figure');

   h105_1 = uicontrol(...
      'Parent',h1,...
      'BackgroundColor',[0.93 0.81 0.63],...
      'Units','pixels',...
      'Callback','nut_beamforming_gui(''nut_save_channels_Callback'',gcbo,[],guidata(gcbo))',...
      'FontSize',9,...
      'ListboxTop',0,...
      'Position',[120 10.5 9 1.8].*[6 12 6 12],...
      'String','Save',...
      'Tag','nut_save_channels_button');
   
   h105_2 = uicontrol(...
      'Parent',h1,...
      'BackgroundColor',[0.93 0.81 0.63],...
      'Units','pixels',...
      'Callback','nut_beamforming_gui(''nut_load_channels_Callback'',gcbo,[],guidata(gcbo))',...
      'FontSize',9,...
      'ListboxTop',0,...
      'Position',[131 10.5 9 1.8].*[6 12 6 12],...
      'String','Load',...
      'Tag','nut_load_channels_button');
   
   h106 = uicontrol(...
      'Parent',h1,...
      'BackgroundColor',[0.93 0.81 0.63],...
      'Units','pixels',...
      'Callback','nut_beamforming_gui(''nut_select_Callback'',gcbo,[],guidata(gcbo))',...
      'FontSize',9,...
      'ListboxTop',0,...
      'Position',[120 4.5 9 1.8].*[6 12 6 12],...
      'String','Add',...
      'Tag','nut_select_button');

   h107 = uicontrol(...
      'Parent',h1,...
      'BackgroundColor',[0.93 0.81 0.63],...
      'Units','pixels',...
      'Callback','nut_beamforming_gui(''nut_select_Callback'',gcbo,[],guidata(gcbo))',...
      'FontSize',9,...
      'ListboxTop',0,...
      'Position',[131 4.5 9 1.8].*[6 12 6 12],...
      'String','Remove',...
      'Tag','nut_deselect_button');
   
   h107b = uicontrol(...
      'Parent',h1,...
      'BackgroundColor',[0.93 0.81 0.63],...
      'Units','pixels',...
      'Callback','nut_beamforming_gui(''nut_beamforming_gui_CloseRequestFcn'',gcbo,[],guidata(gcbo))',...
      'FontSize',9,...
      'ListboxTop',0,...
      'Position',[126 2 8 1.8].*[6 12 6 12],...
      'String','Done',...
      'Tag','nut_done_button');
   
   h108a = uicontrol(...
      'Parent',h1,...
      'BackgroundColor',[0.93 0.93 0.92],...
      'Units','pixels',...
      'FontSize',9,...
      'ListboxTop',0,...
      'HorizontalAlignment','left',...
      'Position',[132.5 29 12 1.8].*[6 12 6 12],...
      'String','Minimum:',...
      'Style','text',...
      'Interruptible','off');
   
   h108 = uicontrol(...
      'Parent',h1,...
      'BackgroundColor',[1 0.93 0.83],...
      'Units','pixels',...
      'Callback','nut_beamforming_gui(''nut_amplitude_Callback'',gcbo,[],guidata(gcbo))',...
      'FontSize',9,...
      'HorizontalAlignment','right',...
      'ListboxTop',0,...
      'Position',[133 28 10 1.7].*[6 12 6 12],...
      'String','',...
      'Style','edit',...
      'Tag','nut_minvalue');
   
   h109a = uicontrol(...
      'Parent',h1,...
      'BackgroundColor',[0.93 0.93 0.92],...
      'Units','pixels',...
      'FontSize',9,...
      'ListboxTop',0,...
      'HorizontalAlignment','left',...
      'Position',[132.5 25 12 1.8].*[6 12 6 12],...
      'String','Maximum:',...
      'Style','text',...
      'Interruptible','off');
   
   h109 = uicontrol(...
      'Parent',h1,...
      'BackgroundColor',[1 0.93 0.83],...
      'Units','pixels',...
      'Callback','nut_beamforming_gui(''nut_amplitude_Callback'',gcbo,[],guidata(gcbo))',...
      'FontSize',9,...
      'HorizontalAlignment','right',...
      'ListboxTop',0,...
      'Position',[133 24 10 1.7].*[6 12 6 12],...
      'String','',...
      'Style','edit',...
      'Tag','nut_maxvalue');
   
   h110 = uicontrol(...
      'Parent',h1,...
      'BackgroundColor',[0.93 0.81 0.63],...
      'Units','pixels',...
      'FontSize',9,...
      'HorizontalAlignment','left',...
      'ListboxTop',0,...
      'Position',[132 21 12 1.7].*[6 12 6 12],...
      'String',' Fix limits',...
      'Value',0,...
      'Style','checkbox',...
      'Tag','nut_fixlimits');

end
%%

hsingleton = h1;

return

%%-------------------------------------------
% --- Handles default GUIDE GUI creation and callback dispatch
function varargout = gui_mainfcn(gui_State, varargin)

gui_StateFields =  {'gui_Name'
                    'gui_Singleton'
                    'gui_OpeningFcn'
                    'gui_OutputFcn'
                    'gui_LayoutFcn'
                    'gui_Callback'};
gui_Mfile = '';
for i=1:length(gui_StateFields)
    if ~isfield(gui_State, gui_StateFields{i})
        error('Could not find field %s in the gui_State struct in GUI M-file %s', gui_StateFields{i}, gui_Mfile);        
    elseif isequal(gui_StateFields{i}, 'gui_Name')
        gui_Mfile = [getfield(gui_State, gui_StateFields{i}), '.m'];
    end
end

numargin = length(varargin);

if numargin == 0
   % NUT_BEAMFORMING_GUI
   % create the GUI
   gui_Create = 1;
   
   % check to see if correct window is already open
   lh = findobj('Tag','nut_beamforming_fig');
   if ~isempty(lh) % if window is already open
      bf_flg = strcmp(get(gcbo,'Tag'),'nut_beamforming_button');
      if (bf_flg & strcmp(get(lh,'Name'),'Channel Selection Tool')) | (~bf_flg & strcmp(get(lh,'Name'),'Beamformer Tool'))
         figure(lh) % incorrect window is open, close current window and continue in order to open correct window
         closereq
      else
         return % correct window already open so do nothing
      end
   end
   
elseif numargin > 3 & ischar(varargin{1}) & ishandle(varargin{2})
   % NUT_BEAMFORMING_GUI('CALLBACK',hObject,eventData,handles,...)
    gui_Create = 0;
else
    % NUT_BEAMFORMING_GUI(...)
    % create the GUI and hand varargin to the openingfcn
    gui_Create = 1;
end

if gui_Create == 0
    varargin{1} = gui_State.gui_Callback;
    if nargout
        [varargout{1:nargout}] = feval(varargin{:});
    else
       feval(varargin{:});
    end
else
    if gui_State.gui_Singleton
        gui_SingletonOpt = 'reuse';
    else
        gui_SingletonOpt = 'new';
    end
    
    % Open fig file with stored settings.  Note: This executes all component
    % specific CreateFunctions with an empty HANDLES structure.
    
   
    % Do feval on layout code in m-file if it exists
    if ~isempty(gui_State.gui_LayoutFcn)
        gui_hFigure = feval(gui_State.gui_LayoutFcn, gui_SingletonOpt);
    else
        gui_hFigure = local_openfig(gui_State.gui_Name, gui_SingletonOpt);            
        % If the figure has InGUIInitialization it was not completely created
        % on the last pass.  Delete this handle and try again.
        if isappdata(gui_hFigure, 'InGUIInitialization')
            delete(gui_hFigure);
            gui_hFigure = local_openfig(gui_State.gui_Name, gui_SingletonOpt);            
        end
    end
    
    % Set flag to indicate starting GUI initialization
    setappdata(gui_hFigure,'InGUIInitialization',1);

    % Fetch GUIDE Application options
    gui_Options = getappdata(gui_hFigure,'GUIDEOptions');
    
    if ~isappdata(gui_hFigure,'GUIOnScreen')
        % Adjust background color
        if gui_Options.syscolorfig 
            set(gui_hFigure,'Color', get(0,'DefaultUicontrolBackgroundColor'));
        end

        % Generate HANDLES structure and store with GUIDATA
        guidata(gui_hFigure, guihandles(gui_hFigure));
    end
    
    % If user specified 'Visible','off' in p/v pairs, don't make the figure
    % visible.
    gui_MakeVisible = 1;
    for ind=1:2:length(varargin)
        if length(varargin) == ind
            break;
        end
        len1 = min(length('visible'),length(varargin{ind}));
        len2 = min(length('off'),length(varargin{ind+1}));
        if ischar(varargin{ind}) & ischar(varargin{ind+1}) & ...
                strncmpi(varargin{ind},'visible',len1) & len2 > 1
            if strncmpi(varargin{ind+1},'off',len2)
                gui_MakeVisible = 0;
            elseif strncmpi(varargin{ind+1},'on',len2)
                gui_MakeVisible = 1;
            end
        end
    end
    
    % Check for figure param value pairs
    for index=1:2:length(varargin)
        if length(varargin) == index
            break;
        end
        try, set(gui_hFigure, varargin{index}, varargin{index+1}), catch, break, end
    end

    % If handle visibility is set to 'callback', turn it on until finished
    % with OpeningFcn
    gui_HandleVisibility = get(gui_hFigure,'HandleVisibility');
    if strcmp(gui_HandleVisibility, 'callback')
        set(gui_hFigure,'HandleVisibility', 'on');
    end
    
    feval(gui_State.gui_OpeningFcn, gui_hFigure, [], guidata(gui_hFigure), varargin{:});
    
    if ishandle(gui_hFigure)
        % Update handle visibility
        set(gui_hFigure,'HandleVisibility', gui_HandleVisibility);
        
        % Make figure visible
        if gui_MakeVisible
            set(gui_hFigure, 'Visible', 'on')
            if gui_Options.singleton 
                setappdata(gui_hFigure,'GUIOnScreen', 1);
            end
        end

        % Done with GUI initialization
        rmappdata(gui_hFigure,'InGUIInitialization');
    end
    
    % If handle visibility is set to 'callback', turn it on until finished with
    % OutputFcn
    if ishandle(gui_hFigure)
        gui_HandleVisibility = get(gui_hFigure,'HandleVisibility');
        if strcmp(gui_HandleVisibility, 'callback')
            set(gui_hFigure,'HandleVisibility', 'on');
        end
        gui_Handles = guidata(gui_hFigure);
    else
        gui_Handles = [];
    end
    
    if nargout
        [varargout{1:nargout}] = feval(gui_State.gui_OutputFcn, gui_hFigure, [], gui_Handles);
    else
        feval(gui_State.gui_OutputFcn, gui_hFigure, [], gui_Handles);
    end
    
    if ishandle(gui_hFigure)
        set(gui_hFigure,'HandleVisibility', gui_HandleVisibility);
    end
end    

function gui_hFigure = local_openfig(name, singleton)
try
    gui_hFigure = openfig(name, singleton, 'auto');
catch
    % OPENFIG did not accept 3rd input argument until R13,
    % toggle default figure visible to prevent the figure
    % from showing up too soon.
    gui_OldDefaultVisible = get(0,'defaultFigureVisible');
    set(0,'defaultFigureVisible','off');
    gui_hFigure = openfig(name, singleton);
    set(0,'defaultFigureVisible',gui_OldDefaultVisible);
end

